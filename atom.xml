<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ren&#39;s Blog</title>
  
  <subtitle>时间仍在，是我们在飞逝</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-12-21T05:57:30.127Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>修饰符public、private和protected的区别</title>
    <link href="http://yoursite.com/2019/08/01/%E4%BF%AE%E9%A5%B0%E7%AC%A6public%E3%80%81private%E5%92%8Cprotected%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/08/01/修饰符public、private和protected的区别/</id>
    <published>2019-08-01T02:50:24.000Z</published>
    <updated>2021-12-21T05:57:30.127Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript 可以使用三种访问修饰符，分别是 public、private 和 protected。</p><ol><li>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的；</li><li>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问；</li><li>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的。</li></ol><p>下面举一些例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  public name;</span><br><span class="line">  public <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>上面的例子中，name 被设置为了 public，所以直接访问实例的 name 属性是允许的。</p><p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  private name;</span><br><span class="line">  public <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">'Jack'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">'Tom'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br><span class="line"><span class="comment">// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br></pre></td></tr></table></figure><p>需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。</p><p>上面的例子编译后的代码是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Animal;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Animal(<span class="string">"Jack"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name);</span><br><span class="line">a.name = <span class="string">"Tom"</span>;</span><br></pre></td></tr></table></figure><p>使用 private 修饰的属性或方法，在子类中也是不允许访问的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  private name;</span><br><span class="line">  public <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(11,17): error TS2341: Property 'name' is private and only accessible within class 'Animal'.</span></span><br></pre></td></tr></table></figure><p>而如果是用 protected 修饰，则允许在子类中访问：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  protected name;</span><br><span class="line">  public <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript 可以使用三种访问修饰符，分别是 public、private 和 protected。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的；&lt;/li&gt;
&lt;li&gt;private 修饰的属性或方法是私有的，不能在声明它的类的外部访问；&lt;/li&gt;
&lt;li&gt;protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面举一些例子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Animal&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  public name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  public &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Animal(&lt;span class=&quot;string&quot;&gt;&#39;Jack&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a.name); &lt;span class=&quot;comment&quot;&gt;// Jack&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a.name = &lt;span class=&quot;string&quot;&gt;&#39;Tom&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a.name); &lt;span class=&quot;comment&quot;&gt;// Tom&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Typescript" scheme="http://yoursite.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>Vue+Typescript 项目起手式</title>
    <link href="http://yoursite.com/2019/07/29/Vue-Typescript-%E9%A1%B9%E7%9B%AE%E8%B5%B7%E6%89%8B%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/07/29/Vue-Typescript-项目起手式/</id>
    <published>2019-07-29T07:23:09.000Z</published>
    <updated>2021-12-21T05:58:22.462Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.xcode.me/wp-content/uploads/2015/11/microsft-type-script.jpg" alt></p><h1 id="什么是-typescript？"><a href="#什么是-typescript？" class="headerlink" title="什么是 typescript？"></a>什么是 typescript？</h1><p><code>Typescript</code> 是 <code>Javascript</code> 的强类型版本。然后在编译期间去掉类型和特有语法，生成纯粹的 <code>JavaScript</code> 代码。由于最终在浏览器中运行的仍然是 <code>JavaScript</code>，所以 <code>TypeScript</code> 并不依赖于浏览器的支持，也并不会带来兼容性问题。</p><p><code>TypeScript</code> 是 <code>JavaScript</code> 的超集，这意味着它支持所有的 <code>JavaScript</code> 语法。并在此之上对 <code>JavaScript</code> 添加了一些扩展，如 <strong><em>class</em></strong> / <strong><em>interface</em></strong> / <strong><em>module</em></strong> 等。这样会大大提升代码的可阅读性。</p><p>与此同时，<code>TypeScript</code> 也是 <code>JavaScript ES6</code> 的超集，<strong>Google</strong> 的 <strong>Angular 2.0</strong> 也宣布采用 <code>TypeScript</code> 进行开发。这更是充分说明了这是一门面向未来并且脚踏实地的语言。</p><a id="more"></a><p>强类型语言的优势在于静态类型检查，<a href="https://www.zhihu.com/question/28016252/answer/39056940" target="_blank" rel="noopener">这里</a>可以具体参见回答。概括来说主要包括以下几点：</p><p>1.静态类型检查<br>2.IDE 智能提示 3.代码重构 4.可读性</p><h1 id="起手-vue-cli"><a href="#起手-vue-cli" class="headerlink" title="起手 vue-cli"></a>起手 vue-cli</h1><p>这步就不详细介绍了，简单写一下构建的几步命令吧~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先npm安装vue-cli3.0</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment"># 创建一个项目</span></span><br><span class="line">vue create hello-ts</span><br><span class="line">或者</span><br><span class="line">vue ui</span><br><span class="line"><span class="comment"># 根据自己的需求选择配置项</span></span><br><span class="line">空格键是否选中，上下选择</span><br><span class="line">······</span><br><span class="line">一路回车，等待依赖下载完毕…</span><br><span class="line"><span class="comment"># 下载完毕，启动项目</span></span><br><span class="line"><span class="built_in">cd</span> hello-ts</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h1 id="vue-config-文件配置"><a href="#vue-config-文件配置" class="headerlink" title="vue config 文件配置"></a>vue config 文件配置</h1><p>下面是我们的文件的结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  文件介绍</span></span><br><span class="line"> 1.   node_modules //当前node模块存放处</span><br><span class="line"> 2.   public //index页面所在静态文件也可以放这个里面（不会被打包）</span><br><span class="line"> 3.   src //当前项目文件夹</span><br><span class="line">        assets //静态文件存放（会被打包）</span><br><span class="line">        components //组件存放</span><br><span class="line">        views //当前项目存放地址</span><br><span class="line">        app.vue //全局路由页面</span><br><span class="line">        main.ts //总的入口文件</span><br><span class="line">        router.ts //路由文件</span><br><span class="line">        shims-tsx.d.ts //兼容jsx</span><br><span class="line">        shims-vue.d.ts //兼容vue</span><br><span class="line">        store.ts //vuex总文件</span><br><span class="line"> 4.  package.json //文件（我们安装的依赖都再里面可以看到，也可以根据这个去下载node_modules）</span><br><span class="line"> 5.  vue.config.js //vue配置，相当于老版本config&gt;index.js</span><br></pre></td></tr></table></figure><p>下面是 vue.conig.js 文件的配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">  <span class="comment">// 当使用基于  HTML 5 history.pushState 的路由时；</span></span><br><span class="line">  <span class="comment">// 当使用 pages 选项构建多页面应用时。</span></span><br><span class="line">  baseUrl: <span class="string">""</span>,</span><br><span class="line">  <span class="comment">// 当运行 vue-cli-service build 时生成的生产环境构建文件的目录。注意目标目录在构建之前会被清除 (构建时传入 --no-clean 可关闭该行为)。</span></span><br><span class="line">  outputDir: <span class="string">"webApp"</span>,</span><br><span class="line">  <span class="comment">// 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录。</span></span><br><span class="line">  assetsDir: <span class="string">"assets"</span>,</span><br><span class="line">  <span class="comment">// 指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径。</span></span><br><span class="line">  indexPath: <span class="string">"index.html"</span>,</span><br><span class="line">  <span class="comment">// 默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。然而，这也要求 index 的 HTML 是被 Vue CLI 自动生成的。如果你无法使用 Vue CLI 生成的 index HTML，你可以通过将这个选项设为 false 来关闭文件名哈希。</span></span><br><span class="line">  filenameHashing: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 多页面</span></span><br><span class="line">  pages: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="comment">// 编译警告</span></span><br><span class="line">  lintOnSave: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 是否使用包含运行时编译器的 Vue 构建版本。设置为 true 后你就可以在 Vue 组件中使用 template 选项了，但是这会让你的应用额外增加 10kb 左右。</span></span><br><span class="line">  runtimeCompiler: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来。eg:"vuex-persist"</span></span><br><span class="line">  transpileDependencies: [],</span><br><span class="line">  <span class="comment">// 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。</span></span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 设置生成的 HTML 中 &lt;link rel="stylesheet"&gt; 和 &lt;script&gt; 标签的 crossorigin 属性。需要注意的是该选项仅影响由 html-webpack-plugin 在构建时注入的标签 - 直接写在模版 (public/index.html) 中的标签不受影响。</span></span><br><span class="line">  crossorigin: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="comment">// 在生成的 HTML 中的 &lt;link rel="stylesheet"&gt; 和 &lt;script&gt; 标签上启用 Subresource Integrity (SRI)。如果你构建后的文件是部署在 CDN 上的，启用该选项可以提供额外的安全性。需要注意的是该选项仅影响由 html-webpack-plugin 在构建时注入的标签 - 直接写在模版 (public/index.html) 中的标签不受影响。另外，当启用 SRI 时，preload resource hints 会被禁用，因为 Chrome 的一个 bug 会导致文件被下载两次。</span></span><br><span class="line">  integrity: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 反向代理</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8008</span>,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">"/api"</span>: &#123;</span><br><span class="line">        <span class="comment">// target: "http://192.168.162.126:8083", //后端服务器地址</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        ws: <span class="literal">true</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">"^/api"</span>: <span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="让-ts-识别-vue"><a href="#让-ts-识别-vue" class="headerlink" title="让 ts 识别.vue"></a>让 ts 识别.vue</h1><p>由于 <code>TypeScript</code> 默认并不支持 <code>*.vue</code> 后缀的文件，所以在 shims-vue.d.ts 文件中需要配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="built_in">module</span> <span class="string">'*.vue'</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><em>敲黑板，下面有重点！</em></p></blockquote><p>意思是告诉 <code>TypeScript</code> <code>*.vue</code> 后缀的文件可以交给 <code>vue</code> 模块来处理。</p><p>而在代码中导入 <code>*.vue</code> 文件的时候，需要写上 <code>.vue</code> 后缀。原因还是因为 <code>TypeScript</code> 默认只识别 <code>*.ts</code> 文件，不识别 <code>*.vue</code> 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">"components/component.vue"</span>;</span><br></pre></td></tr></table></figure><h1 id="改造-vue-文件"><a href="#改造-vue-文件" class="headerlink" title="改造 .vue 文件"></a>改造 .vue 文件</h1><p>在这之前先让我们了解一下所需要的插件（下面的内容需要掌握 es7 的装饰器, 就是下面使用的@符号）</p><h2 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a>vue-class-component</h2><p><strong><em>vue-class-component</em></strong> 对 Vue 组件进行了一层封装，让 Vue 组件语法在结合了 <code>TypeScript</code> 语法之后更加扁平化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=<span class="string">"ts"</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">  <span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'vue-class-component'</span>;</span><br><span class="line"></span><br><span class="line">  @Component</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    msg = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明周期钩子</span></span><br><span class="line">    mounted () &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleClick()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算属性</span></span><br><span class="line">    <span class="keyword">get</span> computedMsg () &#123;<span class="comment">// 读取</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'computed '</span> + <span class="keyword">this</span>.msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> computedMsg (val) &#123;<span class="comment">// 修改</span></span><br><span class="line">      <span class="built_in">console</span>.log(val)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hello: '</span> + <span class="keyword">this</span>.msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码的作用相当于下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="number">123</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明周期钩子</span></span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.handleClick()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算属性</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    computedMsg () &#123;</span><br><span class="line">        <span class="keyword">get</span>:function()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'computed '</span> + <span class="keyword">this</span>.msg;</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="keyword">set</span>:function(val)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(val)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      alert(<span class="string">'hello: '</span> + <span class="keyword">this</span>.msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h2><p><strong><em>vue-property-decorator</em></strong> 是在 vue-class-component 上增强了更多的结合 Vue 特性的装饰器，新增了这 7 个装饰器：</p><ol><li>@Emit</li><li>@Inject</li><li>@Model</li><li>@Prop</li><li>@Provide</li><li>@Watch</li><li>@Component (从 vue-class-component 继承)</li></ol><p>在这里列举几个常用的@Prop/@Watch/@Component, 更多信息，详见<a href="https://github.com/kaorun343/vue-property-decorator" target="_blank" rel="noopener">官方文档</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Component,</span><br><span class="line">  Prop,</span><br><span class="line">  Vue,</span><br><span class="line">  Watch,</span><br><span class="line">  Provide,</span><br><span class="line">  Inject</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"vue-property-decorator"</span>;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">//父子组件之间传值</span></span><br><span class="line">  @Prop(&#123; <span class="attr">default</span>: <span class="string">"default value"</span> &#125;)</span><br><span class="line">  propB: string;</span><br><span class="line"></span><br><span class="line">  @Prop([<span class="built_in">String</span>, <span class="built_in">Boolean</span>])</span><br><span class="line">  propC: string | boolean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//监听数据变化</span></span><br><span class="line">  @Watch(<span class="string">"child"</span>)</span><br><span class="line">  onChildChanged(val: string, <span class="attr">oldVal</span>: string) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @Watch(<span class="string">"person"</span>, &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  onPersonChanged(val: string, <span class="attr">oldVal</span>: string) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//提供</span></span><br><span class="line">  <span class="comment">//父</span></span><br><span class="line">  @Provide(<span class="string">"users"</span>)</span><br><span class="line">  users = [&#123; <span class="attr">name</span>: <span class="string">"test"</span>, <span class="attr">id</span>: <span class="number">0</span> &#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注入</span></span><br><span class="line">  <span class="comment">//子</span></span><br><span class="line">  @Inject(<span class="string">"users"</span>) users;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码的作用相当于下面的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    propB: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'default value'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    propC: [<span class="built_in">String</span>, <span class="built_in">Boolean</span>],</span><br><span class="line">  &#125;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onChildChanged(val, oldVal) &#123; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'child'</span>: &#123;</span><br><span class="line">      handler: <span class="string">'onChildChanged'</span>,</span><br><span class="line">      <span class="comment">//当值第一次绑定的时候，不会执行监听函数，只有值发生改变才会执行。如果我们需要在最初绑定值的时候也执行函数，则就需要用到immediate属性。</span></span><br><span class="line">      immediate: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 深度监听:当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听。</span></span><br><span class="line">      deep: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改路由页面"><a href="#修改路由页面" class="headerlink" title="修改路由页面"></a>修改路由页面</h2><p>路由页面和之前差别也不大<br><img src="/images/ts_router.png" alt></p><h2 id="修改-main-ts"><a href="#修改-main-ts" class="headerlink" title="修改 main.ts"></a>修改 main.ts</h2><p>main.ts 和之前差别也不大<br><img src="/images/ts_main.png" alt></p><h2 id="使用-vuex"><a href="#使用-vuex" class="headerlink" title="使用 vuex"></a>使用 vuex</h2><p>使用方式 vuex-class<br>获取：@State、@Getter、@Action、@Mutation<br><img src="/images/ts_vuex.png" alt></p><h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="让-vue-识别全局方法-变量"><a href="#让-vue-识别全局方法-变量" class="headerlink" title="让 vue 识别全局方法/变量"></a>让 vue 识别全局方法/变量</h2><p>我们经常在 main.ts 中给 vue.prototype 挂载实例或者内容，以方便在组件里面使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import baseURL from <span class="string">"@/api/api"</span>;</span><br><span class="line"><span class="comment"># 其他页面在使用 $baseUrl 的时候直接  this.$baseUrl 就可以了</span></span><br><span class="line">Vue.prototype.<span class="variable">$baseUrl</span> = baseURL.baseURL;</span><br></pre></td></tr></table></figure><p>然而当你在组件中直接 this.$baseUrl 时会报错的，那是因为 $baseUrl  属性，并没有在 vue 实例中声明。<br>报错示例如下：<br><img src="/images/ts_$baseUrl.png" alt></p><p>想要以上做法都正常执行，就还要补充如下内容：<br>在 src 下的 shims-vue.d.ts 中加入要挂载的内容。 表示 vue 里面的 this 下有这些东西。<br><img src="/images/ts_declare.png" alt></p><h2 id="装饰器-Component"><a href="#装饰器-Component" class="headerlink" title="装饰器 @Component"></a>装饰器 @Component</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=<span class="string">"ts"</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123;(Vue, Component)&#125; <span class="keyword">from</span> <span class="string">"vue-property-decorator"</span>; <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class">  <span class="title">index</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>这样写是报错的，以下才是正确写法（因为这里的 Vue 是从 vue-property-decorator import 来的）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=<span class="string">"ts"</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> &#123;(Vue, Component)&#125; <span class="keyword">from</span> <span class="string">"vue-property-decorator"</span>; @Component <span class="keyword">export</span></span><br><span class="line">  <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">index</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="IE-浏览器访问报错缺少”-”"><a href="#IE-浏览器访问报错缺少”-”" class="headerlink" title="IE 浏览器访问报错缺少”)”"></a>IE 浏览器访问报错缺少”)”</h2><p><img src="/images/ie_error.jpg" alt></p><p>猜测是 Es6 语法的问题，经查看错误信息，发现引入的某个包是用 Es6 实现的，babel 没办法转 node_modules 里面的代码，如果我们想要通过 babel 显式转译一个依赖，可以在这个选项中列出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目前为止发现通过Es6实现的依赖包有：</span></span><br><span class="line">transpileDependencies: [<span class="string">'resize-detector'</span>,<span class="string">'vuex-persist'</span>]</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>总的来说，<code>ts</code> 从数据类型、结构入手，通过静态类型检测来增强你代码的健壮性，从而避免 bug 的产生。</p><p>同时可以继续使用 <code>.vue</code> 单文件</p><p>而且我个人认为加上了 <code>typescript</code>，项目逼格提升 2 个 level</p><p>相信之后 <code>vue</code> 对于 <code>ts</code> 的集成会更加友善，期待尤大之后的动作</p><p>以上就是本文的全部内容，希望本文的内容对大家的学习或者工作能带来一定的帮助，也希望大家多多支持~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.xcode.me/wp-content/uploads/2015/11/microsft-type-script.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是-typescript？&quot;&gt;&lt;a href=&quot;#什么是-typescript？&quot; class=&quot;headerlink&quot; title=&quot;什么是 typescript？&quot;&gt;&lt;/a&gt;什么是 typescript？&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Typescript&lt;/code&gt; 是 &lt;code&gt;Javascript&lt;/code&gt; 的强类型版本。然后在编译期间去掉类型和特有语法，生成纯粹的 &lt;code&gt;JavaScript&lt;/code&gt; 代码。由于最终在浏览器中运行的仍然是 &lt;code&gt;JavaScript&lt;/code&gt;，所以 &lt;code&gt;TypeScript&lt;/code&gt; 并不依赖于浏览器的支持，也并不会带来兼容性问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TypeScript&lt;/code&gt; 是 &lt;code&gt;JavaScript&lt;/code&gt; 的超集，这意味着它支持所有的 &lt;code&gt;JavaScript&lt;/code&gt; 语法。并在此之上对 &lt;code&gt;JavaScript&lt;/code&gt; 添加了一些扩展，如 &lt;strong&gt;&lt;em&gt;class&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;interface&lt;/em&gt;&lt;/strong&gt; / &lt;strong&gt;&lt;em&gt;module&lt;/em&gt;&lt;/strong&gt; 等。这样会大大提升代码的可阅读性。&lt;/p&gt;
&lt;p&gt;与此同时，&lt;code&gt;TypeScript&lt;/code&gt; 也是 &lt;code&gt;JavaScript ES6&lt;/code&gt; 的超集，&lt;strong&gt;Google&lt;/strong&gt; 的 &lt;strong&gt;Angular 2.0&lt;/strong&gt; 也宣布采用 &lt;code&gt;TypeScript&lt;/code&gt; 进行开发。这更是充分说明了这是一门面向未来并且脚踏实地的语言。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="Typescript" scheme="http://yoursite.com/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的.toLocaleString()</title>
    <link href="http://yoursite.com/2019/07/08/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-toLocaleString/"/>
    <id>http://yoursite.com/2019/07/08/你不知道的-toLocaleString/</id>
    <published>2019-07-08T08:10:19.000Z</published>
    <updated>2021-12-21T06:03:33.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-toLocaleString-轻松实现多国语言价格数字格式化"><a href="#使用-toLocaleString-轻松实现多国语言价格数字格式化" class="headerlink" title="使用 .toLocaleString() 轻松实现多国语言价格数字格式化"></a>使用 .toLocaleString() 轻松实现多国语言价格数字格式化</h2><p>用代码对数字进行格式化，显然不是逢三位加逗号这么简单。比如印度在数字分位符号上的处理，就堪称业界奇葩：</p><p><code>印度的数字读法用“拉克”（十万）和“克若尔”（千万），数字标法用不对称的数位分离，即小数点左侧首先是三位分隔，然后继续向左都是两位分隔。如：三千万（3 克若尔）会写成 3,00,00,000。 —— 维基百科</code></p><p>简单的暴利处理无法满足多语言支持，此时使用 Number.prototype.toLocaleString() 进行数字格式化处理再好不过。</p><a id="more"></a><h3 id="使用-toLocaleString"><a href="#使用-toLocaleString" class="headerlink" title="使用 .toLocaleString()"></a>使用 .toLocaleString()</h3><p>在 JavaScript 中，数字对象的 .toLocaleString() 方法如果不传参数，则采用宿主环境的系统语言进行分位处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price = <span class="number">1024</span>;</span><br><span class="line">price.toLocaleString(); <span class="comment">// =&gt; "1,024"</span></span><br></pre></td></tr></table></figure><h3 id="使用-locales-参数"><a href="#使用-locales-参数" class="headerlink" title="使用 locales 参数"></a>使用 locales 参数</h3><p>在 ECMA-402 标准的实现中，增加了.toLocaleString() 方法对 locales 的支持，语法为 numObj.toLocaleString([locales [, options]])，locales 参数接收 BCP 47 语言标签格式的字符串或数组。(HTML Language Code Reference, ISO Language Code Table)</p><p>那么将数字强制转化为印度格式就变的简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price = <span class="number">1669999</span>;</span><br><span class="line">price.toLocaleString(<span class="string">"en-IN"</span>); <span class="comment">// =&gt; "16,69,999"</span></span><br></pre></td></tr></table></figure><p>这样就可以轻松处理多语言的自动格式化了，只要根据 <html lang="en-IN"> 中的 lang 属性动态读取就可以了。</html></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price = <span class="number">1669999</span>;</span><br><span class="line"><span class="keyword">var</span> lang = <span class="built_in">document</span>.querySelector(<span class="string">"html"</span>).getAttribute(<span class="string">"lang"</span>);</span><br><span class="line">price.toLocaleString(lang); <span class="comment">// 中文页面下 =&gt; "1,669,999"</span></span><br></pre></td></tr></table></figure><h3 id="使用-options-参数"><a href="#使用-options-参数" class="headerlink" title="使用 options 参数"></a>使用 options 参数</h3><p>如果仅仅是做到多语言自动格式化数字，显然还不够细腻。通过 .toLocaleString() 方法的 options 参数，可以做到转化至相应语言的货币格式。</p><p>在我的项目之前的实现中，多国语言的货币符号是通过模板渲染时读取配置文件完成转换的。如果使用.toLocaleString() 展示或加工展示所有货币数字，则无需这一步骤：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price = <span class="number">2499</span>;</span><br><span class="line">price.toLocaleString(<span class="string">"en-IN"</span>, &#123;</span><br><span class="line">  style: <span class="string">"currency"</span>,</span><br><span class="line">  currency: <span class="string">"INR"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// =&gt; "₹ 2,499.00"</span></span><br></pre></td></tr></table></figure><p>如果不想要显示末尾的小数「.00」，只要设置一下最小分位 minimumFractionDigits 即可（默认是 2）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price = <span class="number">2499</span>;</span><br><span class="line">price.toLocaleString(<span class="string">"en-IN"</span>, &#123;</span><br><span class="line">  style: <span class="string">"currency"</span>,</span><br><span class="line">  currency: <span class="string">"INR"</span>,</span><br><span class="line">  minimumFractionDigits: <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// =&gt; "₹ 2,499"</span></span><br></pre></td></tr></table></figure><p>这样一个完美的价格格式化功能就完成了。options 对象参数接收一系列样式属性，常用的有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">style：可选值为 decimal（小数）、currency（货币）或 percent（百分比）；</span><br><span class="line">currency：设置为货币样式时使用的符号；</span><br><span class="line">minimumFractionDigits：最少保留小数的位数；</span><br><span class="line">maximumFractionDigits：最多保留小数的位数；</span><br><span class="line">useGrouping：布尔值，是否显示数字分位。</span><br></pre></td></tr></table></figure><p><em>注意：currency 设置为货币样式时使用的符号，支持列表在<a href="https://www.currency-iso.org/en/home/tables/table-a1.html" target="_blank" rel="noopener">这里</a>。</em><br>关于 locales 参数和 options 参数支持的其它属性，例如上面使用的 minimumFractionDigits，可以查阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString" target="_blank" rel="noopener">MDN</a>，我刚把最新的英文版翻译了一遍。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>所有现代浏览器都支持 locales 参数，因此在移动端使用是安全无痛的。桌面端的支持则是 IE11 及以上。</p><p>另外，如果想在后端直接对不同页面直接输出对应的货币符或者做分位转换等操作，只要用 node.js 做一个转换就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用-toLocaleString-轻松实现多国语言价格数字格式化&quot;&gt;&lt;a href=&quot;#使用-toLocaleString-轻松实现多国语言价格数字格式化&quot; class=&quot;headerlink&quot; title=&quot;使用 .toLocaleString() 轻松实现多国语言价格数字格式化&quot;&gt;&lt;/a&gt;使用 .toLocaleString() 轻松实现多国语言价格数字格式化&lt;/h2&gt;&lt;p&gt;用代码对数字进行格式化，显然不是逢三位加逗号这么简单。比如印度在数字分位符号上的处理，就堪称业界奇葩：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;印度的数字读法用“拉克”（十万）和“克若尔”（千万），数字标法用不对称的数位分离，即小数点左侧首先是三位分隔，然后继续向左都是两位分隔。如：三千万（3 克若尔）会写成 3,00,00,000。 —— 维基百科&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;简单的暴利处理无法满足多语言支持，此时使用 Number.prototype.toLocaleString() 进行数字格式化处理再好不过。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript面试中经常被问到的三个问题</title>
    <link href="http://yoursite.com/2019/04/17/Javascript%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%BB%8F%E5%B8%B8%E8%A2%AB%E9%97%AE%E5%88%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/04/17/Javascript面试中经常被问到的三个问题/</id>
    <published>2019-04-17T01:59:27.000Z</published>
    <updated>2021-12-21T06:00:46.501Z</updated>
    
    <content type="html"><![CDATA[<p>本文不是讨论最新的 JavaScript 库、常见的开发实践或任何新的 ES6 函数。相反，在讨论 JavaScript 时，面试中通常会提到三件事。我自己也被问到这些问题，我的朋友们告诉我他们也被问到这些问题。</p><p>然，这些并不是你在面试之前应该学习的唯一三件事 - 你可以通过多种方式更好地为即将到来的面试做准备 - 但面试官可能会问到下面是三个问题，来判断你对 <code>JavaScript</code> 语言的理解和 <code>DOM</code> 的掌握程度。</p><p>让我们开始吧！注意，我们将在下面的示例中使用原生的 JavaScript，因为面试官通常希望了解你在没有 jQuery 等库的帮助下对<code>JavaScript</code> 和 <code>DOM</code> 的理解程度。</p><a id="more"></a><h2 id="问题-1-事件委托代理"><a href="#问题-1-事件委托代理" class="headerlink" title="问题 1: 事件委托代理"></a>问题 1: 事件委托代理</h2><p>在构建应用程序时，有时需要将事件绑定到页面上的按钮、文本或图像，以便在用户与元素交互时执行某些操作。</p><p>如果我们以一个简单的待办事项列表为例，面试官可能会告诉你，当用户点击列表中的一个列表项时执行某些操作。他们希望你用 JavaScript 实现这个功能，假设有如下 HTML 代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=<span class="string">"todo-app"</span>&gt;</span><br><span class="line">  &lt;li class=<span class="string">"item"</span>&gt;Walk the dog&lt;/li&gt;</span><br><span class="line">  &lt;li class=<span class="string">"item"</span>&gt;Pay bills&lt;/li&gt;</span><br><span class="line">  &lt;li class=<span class="string">"item"</span>&gt;Make dinner&lt;/li&gt;</span><br><span class="line">  &lt;li class=<span class="string">"item"</span>&gt;Code <span class="keyword">for</span> one hour&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>你可能想要做如下操作来将事件绑定到元素:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> app = <span class="built_in">document</span>.getElementById(<span class="string">"todo-app"</span>);</span><br><span class="line">  <span class="keyword">let</span> itimes = app.getElementsByClassName(<span class="string">"item"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">    item.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">"you clicked on item: "</span> + item.innerHTML);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽然这在技术上是可行的，但问题是要将事件分别绑定到每个项。这对于目前 4 个元素来说，没什么大问题，但是如果在待办事项列表中添加了 10,000 项(他们可能有很多事情要做)怎么办?然后，函数将创建 10,000 个独立的事件侦听器，并将每个事件监听器绑定到 DOM ，这样代码执行的效率非常低下。</p><p>在面试中，最好先问面试官用户可以输入的最大元素数量是多少。例如，如果它不超过 10，那么上面的代码就可以很好地工作。但是如果用户可以输入的条目数量没有限制，那么你应该使用一个更高效的解决方案。</p><p>如果你的应用程序最终可能有数百个事件侦听器，那么更有效的解决方案是<strong>将一个事件侦听器实际绑定到整个容器，然后在单击它时能够访问每个列表项</strong>， 这称为 事件委托，它比附加单独的事件处理程序更有效。</p><p>下面是事件委托的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> app = <span class="built_in">document</span>.getElementById(<span class="string">"todo-app"</span>);</span><br><span class="line"></span><br><span class="line">  app.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.target &amp;&amp; e.target.nodeName === <span class="string">"LI"</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = e.target;</span><br><span class="line">      alert(<span class="string">"you clicked on item: "</span> + item.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="问题-2：-在循环中使用闭包"><a href="#问题-2：-在循环中使用闭包" class="headerlink" title="问题 2： 在循环中使用闭包"></a>问题 2： 在循环中使用闭包</h2><p>闭包常常出现在面试中，以便面试官衡量你对 JS 的熟悉程度，以及你是否知道何时使用闭包。</p><p>闭包基本上是<strong>内部函数可以访问其范围之外的变量</strong>。 闭包可用于实现隐私和创建函数工厂， 闭包常见的面试题如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编写一个函数，该函数将遍历整数列表，并在延迟3秒后打印每个元素的索引。</span><br></pre></td></tr></table></figure><p>经常不正确的写法是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">21</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The index of this number is: "</span> + i);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行上面代码，3 秒延迟后你会看到，实际上每次打印输出是 4，而不是期望的 0，1，2，3 。</p><p>为了正确理解为什么会发生这种情况，了解为什么会在 JavaScript 中发生这种情况将非常有用，这正是面试官试图测试的内容。</p><p>原因是因为 setTimeout 函数创建了一个可以访问其外部作用域的函数（闭包），该作用域是包含索引 i 的循环。 经过 3 秒后，执行该函数并打印出 i 的值，该值在循环结束时为 4，因为它循环经过 0,1,2,3,4 并且循环最终停止在 4。</p><p>实际上有多处方法来正确的解这道题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">i_local</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"The index of this number is: "</span> + i_local);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(i),</span><br><span class="line">    <span class="number">3000</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">21</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"The index of this number is: "</span> + i);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题-3：事件的节流（throttle）与防抖（debounce）"><a href="#问题-3：事件的节流（throttle）与防抖（debounce）" class="headerlink" title="问题 3：事件的节流（throttle）与防抖（debounce）"></a>问题 3：事件的节流（throttle）与防抖（debounce）</h2><p>有些浏览器事件可以在短时间内快速触发多次，比如调整窗口大小或向下滚动页面。例如，监听页面窗口滚动事件，并且用户持续快速地向下滚动页面，那么滚动事件可能在 3 秒内触发数千次，这可能会导致一些严重的性能问题。</p><p>如果在面试中讨论构建应用程序，出现滚动、窗口大小调整或按下键等事件请务必提及 <strong>防抖(Debouncing)</strong> 和 <strong>函数节流（Throttling）</strong>来提升页面速度和性能。这两兄弟的本质都是以<strong>闭包</strong>的形式存在。通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用 setTimeout 来控制事件的触发频率。</p><h3 id="Throttle：-第一个人说了算"><a href="#Throttle：-第一个人说了算" class="headerlink" title="Throttle： 第一个人说了算"></a>Throttle： 第一个人说了算</h3><p>throttle 的主要思想在于：在某段时间内，不管你触发了多少次回调，都只认第一次，并在计时结束时给予响应。</p><p>这个故事里，‘裁判’ 就是我们的节流阀， 他控制参赛者吃东西的时机， “参赛者吃东西”就是我们频繁操作事件而不断涌入的回调任务，它受 “裁判” 的控制,而计时器，就是上文提到的以自由变量形式存在的时间信息，它是 “裁判” 决定是否停止比赛的依据，最后，等待比赛结果就对应到回调函数的执行。</p><p>总结下来，所谓的“节流”，是通过在一段时间内无视后来产生的回调请求来实现的。只要 裁判宣布比赛开始，裁判就会开启计时器，在这段时间内，参赛者就尽管不断的吃，谁也无法知道最终结果。</p><p>对应到实际的交互上是一样一样的：每当用户触发了一次 scroll 事件，我们就为这个触发操作开启计时器。一段时间内，后续所有的 scroll 事件都会被当作“参赛者吃东西——它们无法触发新的 scroll 回调。直到“一段时间”到了，第一次触发的 scroll 事件对应的回调才会执行，而“一段时间内”触发的后续的 scroll 回调都会被节流阀无视掉。</p><p>现在一起实现一个 throttle：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, interval是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last为上一次触发回调的时间</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将throttle处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">    <span class="keyword">if</span> (now - last &gt;= interval) &#123;</span><br><span class="line">      <span class="comment">// 如果时间间隔大于我们设定的时间间隔阈值，则执行回调</span></span><br><span class="line">      last = now;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用throttle来包装scroll的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"触发了滚动事件"</span>), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"scroll"</span>, better_scroll);</span><br></pre></td></tr></table></figure><h3 id="Debounce：-最后一个参赛者说了算"><a href="#Debounce：-最后一个参赛者说了算" class="headerlink" title="Debounce： 最后一个参赛者说了算"></a>Debounce： 最后一个参赛者说了算</h3><p>防抖的主要思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。</p><p>继续大胃王比赛故事，这次换了一种比赛方式，时间不限，参赛者吃到不能吃为止，当每个参赛都吃不下的时候，后面 10 分钟如果没有人在吃，比赛结束，如果有人在 10 分钟内还能吃，则比赛继续，直到下一次 10 分钟内无人在吃时为止。</p><p>对比 throttle 来理解 debounce： 在 throttle 的逻辑里， ‘裁判’ 说了算，当比赛时间到时，就执行回调函数。而 debounce 认为最后一个参赛者说了算，只要还能吃的，就重新设定新的定时器。</p><p>现在一起实现一个 debounce：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, delay是每次推迟执行的等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将debounce处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次事件被触发时，都去清除之前的旧定时器</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设立新定时器</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用debounce来包装scroll的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = debounce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"触发了滚动事件"</span>), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"scroll"</span>, better_scroll);</span><br></pre></td></tr></table></figure><h3 id="用-Throttle-来优化-Debounce"><a href="#用-Throttle-来优化-Debounce" class="headerlink" title="用 Throttle 来优化 Debounce"></a>用 Throttle 来优化 Debounce</h3><p>debounce 的问题在于它“太有耐心了”。试想，如果用户的操作十分频繁——他每次都不等 debounce 设置的 delay 时间结束就进行下一次操作，于是每次 debounce 都为该用户重新生成定时器，回调函数被延迟了不计其数次。频繁的延迟会导致用户迟迟得不到响应，用户同样会产生“这个页面卡死了”的观感。</p><p>为了避免弄巧成拙，我们需要借力 throttle 的思想，打造一个“有底线”的 debounce——等你可以，但我有我的原则：delay 时间内，我可以为你重新生成定时器；但只要 delay 的时间到了，我必须要给用户一个响应。这个 throttle 与 debounce “合体”思路，已经被很多成熟的前端库应用到了它们的加强版 throttle 函数的实现中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn是我们需要包装的事件回调, delay是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last为上一次触发回调的时间, timer是定时器</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>,</span><br><span class="line">    timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 将throttle处理结果当作函数返回</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">    <span class="keyword">if</span> (now - last &lt; delay) &#123;</span><br><span class="line">      <span class="comment">// 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器</span></span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        last = now;</span><br><span class="line">        fn.apply(context, args);</span><br><span class="line">      &#125;, delay);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应</span></span><br><span class="line">      last = now;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用新的throttle包装scroll的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"触发了滚动事件"</span>), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"scroll"</span>, better_scroll);</span><br></pre></td></tr></table></figure><p><img src="https://image-static.segmentfault.com/941/111/941111876-5c6f3c01179db_articlex" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文不是讨论最新的 JavaScript 库、常见的开发实践或任何新的 ES6 函数。相反，在讨论 JavaScript 时，面试中通常会提到三件事。我自己也被问到这些问题，我的朋友们告诉我他们也被问到这些问题。&lt;/p&gt;
&lt;p&gt;然，这些并不是你在面试之前应该学习的唯一三件事 - 你可以通过多种方式更好地为即将到来的面试做准备 - 但面试官可能会问到下面是三个问题，来判断你对 &lt;code&gt;JavaScript&lt;/code&gt; 语言的理解和 &lt;code&gt;DOM&lt;/code&gt; 的掌握程度。&lt;/p&gt;
&lt;p&gt;让我们开始吧！注意，我们将在下面的示例中使用原生的 JavaScript，因为面试官通常希望了解你在没有 jQuery 等库的帮助下对&lt;code&gt;JavaScript&lt;/code&gt; 和 &lt;code&gt;DOM&lt;/code&gt; 的理解程度。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>element-ui实现dialog可拖拽位置及宽高</title>
    <link href="http://yoursite.com/2019/02/22/element-ui%E5%AE%9E%E7%8E%B0dialog%E5%8F%AF%E6%8B%96%E6%8B%BD%E4%BD%8D%E7%BD%AE%E5%8F%8A%E5%AE%BD%E9%AB%98/"/>
    <id>http://yoursite.com/2019/02/22/element-ui实现dialog可拖拽位置及宽高/</id>
    <published>2019-02-22T10:13:38.000Z</published>
    <updated>2021-12-21T05:59:09.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开头必讲"><a href="#开头必讲" class="headerlink" title="开头必讲"></a>开头必讲</h2><p>1.每个弹窗都要有唯一 dom 可操作 指令可以做到 2.拖拽时要添加可拖拽区块 header 3.由于 element-ui dialog 组件在设计时宽度用了百分比, 这里不同浏览器有兼容性问题 4.实现拖拽宽高时 获取边缘问题 div 定位 设置模拟边缘</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;el-dialog v-dialogDrag ref=<span class="string">"dialog__wrapper"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"dialog-body"</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">"line"</span> v-dialogDragWidth=<span class="string">"<span class="variable">$refs</span>.dialog__wrapper"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/el-dialog&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h2><p>dialog 组件的其它属性这里就不写了. 项目中的指令都定义 directives.js 中集中管理, 全局注册.<br>directives.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// v-dialogDrag: 弹窗拖拽</span></span><br><span class="line">Vue.directive(<span class="string">"dialogDrag"</span>, &#123;</span><br><span class="line">  bind(el, binding, vnode, oldVnode) &#123;</span><br><span class="line">    <span class="keyword">const</span> dialogHeaderEl = el.querySelector(<span class="string">".el-dialog__header"</span>);</span><br><span class="line">    <span class="keyword">const</span> dragDom = el.querySelector(<span class="string">".el-dialog"</span>);</span><br><span class="line">    dialogHeaderEl.style.cursor = <span class="string">"move"</span>;</span><br><span class="line">    <span class="comment">// 获取原有属性 ie dom元素.currentStyle 火狐谷歌 window.getComputedStyle(dom元素, null);</span></span><br><span class="line">    <span class="keyword">const</span> sty = dragDom.currentStyle || <span class="built_in">window</span>.getComputedStyle(dragDom, <span class="literal">null</span>);</span><br><span class="line">    dialogHeaderEl.onmousedown = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 鼠标按下，计算当前元素距离可视区的距离</span></span><br><span class="line">      <span class="keyword">const</span> disX = e.clientX - dialogHeaderEl.offsetLeft;</span><br><span class="line">      <span class="keyword">const</span> disY = e.clientY - dialogHeaderEl.offsetTop;</span><br><span class="line">      <span class="comment">// 获取到的值带px 正则匹配替换</span></span><br><span class="line">      <span class="keyword">let</span> styL, styT;</span><br><span class="line">      <span class="comment">// 注意在ie中 第一次获取到的值为组件自带50% 移动之后赋值为px</span></span><br><span class="line">      <span class="keyword">if</span> (sty.left.includes(<span class="string">"%"</span>)) &#123;</span><br><span class="line">        styL =</span><br><span class="line">          +<span class="built_in">document</span>.body.clientWidth * (+sty.left.replace(<span class="regexp">/\%/g</span>, <span class="string">""</span>) / <span class="number">100</span>);</span><br><span class="line">        styT =</span><br><span class="line">          +<span class="built_in">document</span>.body.clientHeight * (+sty.top.replace(<span class="regexp">/\%/g</span>, <span class="string">""</span>) / <span class="number">100</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        styL = +sty.left.replace(<span class="regexp">/\px/g</span>, <span class="string">""</span>);</span><br><span class="line">        styT = +sty.top.replace(<span class="regexp">/\px/g</span>, <span class="string">""</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 通过事件委托，计算移动的距离</span></span><br><span class="line">        <span class="keyword">const</span> l = e.clientX - disX;</span><br><span class="line">        <span class="keyword">const</span> t = e.clientY - disY;</span><br><span class="line">        <span class="comment">// 移动当前元素</span></span><br><span class="line">        dragDom.style.left = <span class="string">`<span class="subst">$&#123;l + styL&#125;</span>px`</span>;</span><br><span class="line">        dragDom.style.top = <span class="string">`<span class="subst">$&#123;t + styT&#125;</span>px`</span>;</span><br><span class="line">        <span class="comment">//将此时的位置传出去</span></span><br><span class="line">        <span class="comment">//binding.value(&#123;x:e.pageX,y:e.pageY&#125;)</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// v-dialogDragWidth: 弹窗宽度拖大 拖小</span></span><br><span class="line">Vue.directive(<span class="string">"dialogDragWidth"</span>, &#123;</span><br><span class="line">  bind(el, binding, vnode, oldVnode) &#123;</span><br><span class="line">    <span class="keyword">const</span> dragDom = binding.value.$el.querySelector(<span class="string">".el-dialog"</span>);</span><br><span class="line">    el.onmousedown = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 鼠标按下，计算当前元素距离可视区的距离</span></span><br><span class="line">      <span class="keyword">const</span> disX = e.clientX - el.offsetLeft;</span><br><span class="line">      <span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        e.preventDefault(); <span class="comment">// 移动时禁用默认事件</span></span><br><span class="line">        <span class="comment">// 通过事件委托，计算移动的距离</span></span><br><span class="line">        <span class="keyword">const</span> l = e.clientX - disX;</span><br><span class="line">        dragDom.style.width = <span class="string">`<span class="subst">$&#123;l&#125;</span>px`</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="引入指令"><a href="#引入指令" class="headerlink" title="引入指令"></a>引入指令</h2><p>main.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入自定义指令</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"./directives.js"</span>;</span><br></pre></td></tr></table></figure><p>是不是很简单呢~赶紧推荐给好友阅读使用吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开头必讲&quot;&gt;&lt;a href=&quot;#开头必讲&quot; class=&quot;headerlink&quot; title=&quot;开头必讲&quot;&gt;&lt;/a&gt;开头必讲&lt;/h2&gt;&lt;p&gt;1.每个弹窗都要有唯一 dom 可操作 指令可以做到 2.拖拽时要添加可拖拽区块 header 3.由于 element-ui dialog 组件在设计时宽度用了百分比, 这里不同浏览器有兼容性问题 4.实现拖拽宽高时 获取边缘问题 div 定位 设置模拟边缘&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>VueJS学习使用Vuex详解</title>
    <link href="http://yoursite.com/2019/01/07/VueJS%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8Vuex%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/01/07/VueJS学习使用Vuex详解/</id>
    <published>2019-01-07T09:21:50.000Z</published>
    <updated>2021-12-21T06:02:16.347Z</updated>
    
    <content type="html"><![CDATA[<p>在 SPA 单页面组件的开发中 Vue 的 vuex 和 React 的 Redux 都统称为同一状态管理，个人的理解是全局状态管理更合适；简单的理解就是你在 state 中定义了一个数据之后，你可以在所在项目中的任何一个组件里进行获取、进行修改，并且你的修改可以得到全局的响应变更。下面咱们一步一步地剖析下 vuex 的使用:<br>首先要安装、使用 vuex<br>首先在 vue 2.0+ 你的 vue-cli 项目中安装 vuex :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure><a id="more"></a><p>然后 在 src 文件目录下新建一个名为 store 的文件夹，为方便引入并在 store 文件夹里新建一个 index.js,里面的内容如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>接下来，在 main.js 里面引入 store，然后再全局注入一下，这样一来就可以在任何一个组件里面使用 this.$store 了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">"./store"</span>; <span class="comment">//引入store</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  router,</span><br><span class="line">  store, <span class="comment">//使用store</span></span><br><span class="line">  template: <span class="string">"&lt;App/&gt;"</span>,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>说了上面的前奏之后，接下来就是纳入正题了，就是开篇说的 state 的玩法。回到 store 文件的 index.js 里面，我们先声明一个 state 变量，并赋值一个空对象给它，里面随便定义两个初始属性值；然后再在实例化的 Vuex.Store 里面传入一个空对象，并把刚声明的变量 state 仍里面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="comment">//要设置的全局访问的state对象</span></span><br><span class="line">  showFooter: <span class="literal">true</span>,</span><br><span class="line">  changableNum: <span class="number">0</span></span><br><span class="line">  <span class="comment">//要设置的初始属性值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>实际上做完上面的三个步骤后，你已经可以用 this.store.state.showFooter 或 this.store.state.changebleNum 在任何一个组件里面获取 showfooter 和 changebleNum 定义的值了，但这不是理想的获取方式；vuex 官方 API 提供了一个 getters，和 vue 计算属性 computed 一样，来实时监听 state 值的变化(最新状态)，并把它也仍进 Vuex.Store 里面，具体看下面代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="comment">//要设置的全局访问的state对象</span></span><br><span class="line">  showFooter: <span class="literal">true</span>,</span><br><span class="line">  changableNum: <span class="number">0</span></span><br><span class="line">  <span class="comment">//要设置的初始属性值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="comment">//实时监听state值的变化(最新状态)</span></span><br><span class="line">  isShow(state) &#123;</span><br><span class="line">    <span class="comment">//方法名随意,主要是来承载变化的showFooter的值</span></span><br><span class="line">    <span class="keyword">return</span> state.showFooter;</span><br><span class="line">  &#125;,</span><br><span class="line">  getChangedNum() &#123;</span><br><span class="line">    <span class="comment">//方法名随意,主要是用来承载变化的changableNum的值</span></span><br><span class="line">    <span class="keyword">return</span> state.changebleNum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  getters</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>光有定义的 state 的初始值，不改变它不是我们想要的需求，接下来要说的就是 mutations 了，mutattions 也是一个对象，这个对象里面可以放改变 state 的初始值的方法，具体的用法就是给里面的方法传入参数 state 或额外的参数,然后利用 vue 的双向数据驱动进行值的改变，同样的定义好之后也把这个 mutations 扔进 Vuex.Store 里面，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="comment">//要设置的全局访问的state对象</span></span><br><span class="line">  showFooter: <span class="literal">true</span>,</span><br><span class="line">  changableNum: <span class="number">0</span></span><br><span class="line">  <span class="comment">//要设置的初始属性值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="comment">//实时监听state值的变化(最新状态)</span></span><br><span class="line">  isShow(state) &#123;</span><br><span class="line">    <span class="comment">//承载变化的showFooter的值</span></span><br><span class="line">    <span class="keyword">return</span> state.showFooter;</span><br><span class="line">  &#125;,</span><br><span class="line">  getChangedNum() &#123;</span><br><span class="line">    <span class="comment">//承载变化的changebleNum的值</span></span><br><span class="line">    <span class="keyword">return</span> state.changableNum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  show(state) &#123;</span><br><span class="line">    <span class="comment">//自定义改变state初始值的方法，这里面的参数除了state之外还可以再传额外的参数(变量或对象);</span></span><br><span class="line">    state.showFooter = <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  hide(state) &#123;</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    state.showFooter = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  newNum(state, sum) &#123;</span><br><span class="line">    <span class="comment">//同上，这里面的参数除了state之外还传了需要增加的值sum</span></span><br><span class="line">    state.changableNum += sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  mutations</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>这时候你完全可以用 this.store.commit(′show′)或 this.store.commit(‘hide’) 以及 this.store.commit(′newNum′,6)在别的组件里面进行改变 showfooter 和 changebleNum 的值了，但这不是理想的改变值的方式；因为在 Vuex 中，mutations 里面的方法都是同步事务，意思就是说：比如这里的一个 this.store.commit(‘newNum’,sum)方法,两个组件里用执行得到的值，每次都是一样的，这样肯定不是理想的需求</p><p>好在 vuex 官方 API 还提供了一个 actions，这个 actions 也是个对象变量，最大的作用就是里面的 Action 方法 可以包含任意异步操作，这里面的方法是用来异步触发 mutations 里面的方法，actions 里面自定义的函数接收一个 context 参数和要变化的形参，context 与 store 实例具有相同的方法和属性，所以它可以执行 context.commit(‘ ‘),然后也不要忘了把它也扔进 Vuex.Store 里面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="comment">//要设置的全局访问的state对象</span></span><br><span class="line">  showFooter: <span class="literal">true</span>,</span><br><span class="line">  changableNum: <span class="number">0</span></span><br><span class="line">  <span class="comment">//要设置的初始属性值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="comment">//实时监听state值的变化(最新状态)</span></span><br><span class="line">  isShow(state) &#123;</span><br><span class="line">    <span class="comment">//承载变化的showFooter的值</span></span><br><span class="line">    <span class="keyword">return</span> state.showFooter;</span><br><span class="line">  &#125;,</span><br><span class="line">  getChangedNum() &#123;</span><br><span class="line">    <span class="comment">//承载变化的changebleNum的值</span></span><br><span class="line">    <span class="keyword">return</span> state.changableNum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  show(state) &#123;</span><br><span class="line">    <span class="comment">//自定义改变state初始值的方法，这里面的参数除了state之外还可以再传额外的参数(变量或对象);</span></span><br><span class="line">    state.showFooter = <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  hide(state) &#123;</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    state.showFooter = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  newNum(state, sum) &#123;</span><br><span class="line">    <span class="comment">//同上，这里面的参数除了state之外还传了需要增加的值sum</span></span><br><span class="line">    state.changableNum += sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  hideFooter(context) &#123;</span><br><span class="line">    <span class="comment">//自定义触发mutations里函数的方法，context与store 实例具有相同方法和属性</span></span><br><span class="line">    context.commit(<span class="string">"hide"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  showFooter(context) &#123;</span><br><span class="line">    <span class="comment">//同上注释</span></span><br><span class="line">    context.commit(<span class="string">"show"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  getNewNum(context, num) &#123;</span><br><span class="line">    <span class="comment">//同上注释，num为要变化的形参</span></span><br><span class="line">    context.commit(<span class="string">"newNum"</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p>而在外部组件里进行全局执行 actions 里面方法的时候，你只需要用执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'hideFooter'</span>)</span><br><span class="line"></span><br><span class="line">或<span class="keyword">this</span>.$store.dispatch(<span class="string">'showFooter'</span>)</span><br><span class="line"></span><br><span class="line">以及<span class="keyword">this</span>.$store.dispatch(<span class="string">'getNewNum'</span>，<span class="number">6</span>) <span class="comment">//6要变化的实参</span></span><br></pre></td></tr></table></figure><p>这样就可以全局改变改变 showfooter 或 changebleNum 的值了，如下面的组件中,需求是跳转组件页面后，根据当前所在的路由页面进行隐藏或显示页面底部的 tabs 选项卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">   &lt;router-view/&gt;</span><br><span class="line">   &lt;FooterBar v-if=<span class="string">"isShow"</span> /&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import FooterBar from <span class="string">'@/components/common/FooterBar'</span></span><br><span class="line">import config from <span class="string">'./config/index'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line"> name: <span class="string">'App'</span>,</span><br><span class="line"> components:&#123;</span><br><span class="line">   FooterBar:FooterBar</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">   <span class="built_in">return</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> computed:&#123;</span><br><span class="line">    <span class="function"><span class="title">isShow</span></span>()&#123;</span><br><span class="line">      <span class="built_in">return</span> this.<span class="variable">$store</span>.getters.isShow;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> watch:&#123;</span><br><span class="line">     <span class="variable">$route</span>(to,from)&#123; //跳转组件页面后，监听路由参数中对应的当前页面以及上一个页面</span><br><span class="line">         console.log(to)</span><br><span class="line">       <span class="keyword">if</span>(to.name==<span class="string">'book'</span>||to.name==<span class="string">'my'</span>)&#123; // to.name来获取当前所显示的页面，从而控制该显示或隐藏footerBar组件</span><br><span class="line">          this.<span class="variable">$store</span>.dispatch(<span class="string">'showFooter'</span>) // 利用派发全局state.showFooter的值来控制        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          this.<span class="variable">$store</span>.dispatch(<span class="string">'hideFooter'</span>)</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          this.<span class="variable">$store</span>.dispatch(<span class="string">'hideFooter'</span>)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此就可以做到一呼百应的全局响应状态改变了！</p><p>modules 模块化 以及 组件中引入 mapGetters、mapActions 和 mapStates 的使用</p><p>因为在大多数的项目中，我们对于全局状态的管理并不仅仅一种情况的需求，有时有多方面的需求，比如写一个商城项目，你所用到的全局 state 可能是关于购物车这一块儿的也有可能是关于商品价格这一块儿的；像这样的情况我们就要考虑使用 vuex 中的 modules 模块化了，具体怎么使用 modules 呢？咱们继续一步一步的走：</p><p>首先，在 store 文件夹下面新建一个 modules 文件夹，然后在 modules 文件里面建立需要管理状态的 js 文件，既然要把不同部分的状态分开管理，那就要把它们给分成独立的状态文件了，如下图：</p><p><img src="/images/vueximg1.png" alt></p><p>而对应的 store 文件夹下面的 index.js 里面的内容就直接改写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line"><span class="keyword">import</span> footerStatus <span class="keyword">from</span> <span class="string">"./modules/footerStatus"</span>;</span><br><span class="line"><span class="keyword">import</span> collection <span class="keyword">from</span> <span class="string">"./modules/collection"</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    footerStatus,</span><br><span class="line">    collection</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>相应的 js，其中的 namespaced:true 表示当你需要在别的文件里面使用( mapGetters、mapActions 接下来会说 )时，里面的方法需要注明来自哪一个模块的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//collection.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  collects: [] <span class="comment">//初始化一个colects数组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  renderCollects(state) &#123;</span><br><span class="line">    <span class="comment">//承载变化的collects</span></span><br><span class="line">    <span class="keyword">return</span> state.collects;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  pushCollects(state, items) &#123;</span><br><span class="line">    <span class="comment">//如何变化collects,插入items</span></span><br><span class="line">    state.collects.push(items);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  invokePushItems(context, item) &#123;</span><br><span class="line">    <span class="comment">//触发mutations里面的pushCollects ,传入数据形参item 对应到items</span></span><br><span class="line">    context.commit(<span class="string">"pushCollects"</span>, item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>, <span class="comment">//用于在全局引用此文件里的方法时标识这一个的文件名</span></span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//footerStatus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="comment">//要设置的全局访问的state对象</span></span><br><span class="line">  showFooter: <span class="literal">true</span>,</span><br><span class="line">  changableNum: <span class="number">0</span></span><br><span class="line">  <span class="comment">//要设置的初始属性值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  <span class="comment">//实时监听state值的变化(最新状态)</span></span><br><span class="line">  isShow(state) &#123;</span><br><span class="line">    <span class="comment">//承载变化的showFooter的值</span></span><br><span class="line">    <span class="keyword">return</span> state.showFooter;</span><br><span class="line">  &#125;,</span><br><span class="line">  getChangedNum() &#123;</span><br><span class="line">    <span class="comment">//承载变化的changebleNum的值</span></span><br><span class="line">    <span class="keyword">return</span> state.changableNum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  show(state) &#123;</span><br><span class="line">    <span class="comment">//自定义改变state初始值的方法，这里面的参数除了state之外还可以再传额外的参数(变量或对象);</span></span><br><span class="line">    state.showFooter = <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  hide(state) &#123;</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    state.showFooter = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  newNum(state, sum) &#123;</span><br><span class="line">    <span class="comment">//同上，这里面的参数除了state之外还传了需要增加的值sum</span></span><br><span class="line">    state.changableNum += sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  hideFooter(context) &#123;</span><br><span class="line">    <span class="comment">//自定义触发mutations里函数的方法，context与store 实例具有相同方法和属性</span></span><br><span class="line">    context.commit(<span class="string">"hide"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  showFooter(context) &#123;</span><br><span class="line">    <span class="comment">//同上注释</span></span><br><span class="line">    context.commit(<span class="string">"show"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  getNewNum(context, num) &#123;</span><br><span class="line">    <span class="comment">//同上注释，num为要变化的形参</span></span><br><span class="line">    context.commit(<span class="string">"newNum"</span>, num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  namespaced: <span class="literal">true</span>, <span class="comment">//用于在全局引用此文里的方法时标识这一个的文件名</span></span><br><span class="line">  state,</span><br><span class="line">  getters,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一改就有了关于两个模块的 state 管理文件了 footerStatus.js 和 collection.js，现在你要运行当前的代码话，项目会报错！因为我们把上面的代码模块化分开了，引用的地方还没有改。接下来咱们一起来看看 mapState,mapGetters,mapActions 的使用，首先 在需要用的 组件里面先导入 import {mapState,mapGetters,mapActions} from ‘vuex’;咱们先修正一下隐藏或显示页面底部的 tabs 选项卡（就是上面举的临时例子）的组件代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;router-view/&gt;</span><br><span class="line">  &lt;FooterBar v-if=<span class="string">"isShow"</span> /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;mapState,mapGetters,mapActions&#125; from <span class="string">'vuex'</span>; //先要引入</span><br><span class="line">import FooterBar from <span class="string">'@/components/common/FooterBar'</span></span><br><span class="line">import config from <span class="string">'./config/index'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">name: <span class="string">'App'</span>,</span><br><span class="line">components:&#123;</span><br><span class="line">  FooterBar:FooterBar</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">  ...mapState(&#123;  //这里的...是超引用，ES6的语法，意思是state里有多少属性值我可以在这里放多少属性值</span><br><span class="line">       isShow:state=&gt;state.footerStatus.showFooter //注意这些与上面的区别就是state.footerStatus,</span><br><span class="line">                                                    //里面定义的showFooter是指footerStatus.js里state的showFooter</span><br><span class="line">    &#125;),</span><br><span class="line">   //你也可以用下面的mapGetters来获取isShow的值，貌似下面的更简洁</span><br><span class="line">  /*...mapGetters(<span class="string">'footerStatus'</span>,&#123; //footerStatus指的是modules文件夹下的footerStatus.js模块</span><br><span class="line">       isShow:<span class="string">'isShow'</span> //第一个isShow是我自定义的只要对应template里v-if=<span class="string">"isShow"</span>就行，</span><br><span class="line">                       //第二个isShow是对应的footerStatus.js里的getters里的isShow</span><br><span class="line">    &#125;)*/</span><br><span class="line">&#125;,</span><br><span class="line">watch:&#123;</span><br><span class="line">    <span class="variable">$route</span>(to,from)&#123;</span><br><span class="line">      <span class="keyword">if</span>(to.name==<span class="string">'book'</span>||to.name==<span class="string">'my'</span>)&#123;</span><br><span class="line">         this.<span class="variable">$store</span>.dispatch(<span class="string">'footerStatus/showFooter'</span>) //这里改为<span class="string">'footerStatus/showFooter'</span>,</span><br><span class="line">                                                         //意思是指footerStatus.js里actions里的showFooter方法</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         this.<span class="variable">$store</span>.dispatch(<span class="string">'footerStatus/hideFooter'</span>) //同上注释</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>现在项目代码应该就不会报错了，好,最后咱们再来看一下 mapActions 的用法，实际上上面的 this.$store.dispatch(‘footerStatus/showFooter’)已经算是一种执行相应模块的 action 里的方法了，但有时会牵扯的事件的触发及传值，那就会有下面的 mapActions 用法了,还记得上面的另一个模块 collection.js 吗？来看一下里面的 actions 中的方法结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  collects: [] <span class="comment">//初始化一个colects数组</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  renderCollects(state) &#123;</span><br><span class="line">    <span class="comment">//承载变化的collects</span></span><br><span class="line">    <span class="keyword">return</span> state.collects;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  pushCollects(state, items) &#123;</span><br><span class="line">    <span class="comment">//如何变化collects,插入items</span></span><br><span class="line">    state.collects.push(items);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  invokePushItems(context, item) &#123;</span><br><span class="line">    <span class="comment">//触发mutations里面的pushCollects ,传入数据形参item 对应到items</span></span><br><span class="line">    context.commit(<span class="string">"pushCollects"</span>, item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要传值来实时变动 state.collects 里的数据，那肯定要在执行它的地方进行传值了，所以下面用到它的地方我们用了个@click 来执行这个 invokePushItems 方法了，并且传入相应的对象数据 item,如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div &gt;</span><br><span class="line">      &lt;section class=<span class="string">"joinState"</span>&gt;</span><br><span class="line">           &lt;div class=<span class="string">"joinStateHead"</span>&gt;</span><br><span class="line">                &lt;span class=<span class="string">"h3"</span>&gt;全国改性料通讯录&lt;/span&gt;</span><br><span class="line">                &lt;span class=<span class="string">"joinStatus"</span> @click=<span class="string">"invokePushItems(item)"</span>&gt;加入收藏列&lt;/span&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">      &lt;/section&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; mapActions &#125; from <span class="string">'vuex'</span></span><br><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  components:&#123;</span><br><span class="line">     conditionFilter</span><br><span class="line">  &#125;,</span><br><span class="line">  name: <span class="string">'bookDetail'</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span></span> () &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      msg: <span class="string">''</span>,</span><br><span class="line">      item:&#123;</span><br><span class="line">         id:<span class="string">'01'</span>,</span><br><span class="line">         productName: <span class="string">'苹果'</span>,</span><br><span class="line">         price:<span class="string">'1.6元/斤'</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span></span>() &#123;</span><br><span class="line">    this.<span class="variable">$store</span>.dispatch(<span class="string">'footerStatus/hideFooter'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">      ...mapActions(<span class="string">'collection'</span>,[ //collection是指modules文件夹下的collection.js</span><br><span class="line">          <span class="string">'invokePushItems'</span>  //collection.js文件中的actions里的方法，在上面的@click中执行并传入实参</span><br><span class="line">      ])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样一来，在这个组件里面操作的 collecttion.js 中的 state 的数据，在其他的任何的一个组件里面都会得到相应的更新变化了，获取状态的页面代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">       &lt;ul&gt;</span><br><span class="line">           &lt;li v-for=<span class="string">"(val,index) in arrList"</span> :key=<span class="string">"index"</span>&gt;</span><br><span class="line">               &lt;h5&gt;&#123;&#123;val.productName&#125;&#125;&lt;/h5&gt;</span><br><span class="line">                &lt;p&gt;&#123;&#123;val.price&#125;&#125;&lt;/p&gt;</span><br><span class="line">           &lt;/li&gt;</span><br><span class="line">       &lt;/ul&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;mapState,mapGetters,mapActions&#125; from <span class="string">'vuex'</span>;</span><br><span class="line">   <span class="built_in">export</span> default &#123;</span><br><span class="line">       name: <span class="string">'book'</span>,</span><br><span class="line">       <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">           <span class="built_in">return</span> &#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">   computed:&#123;</span><br><span class="line">       // ...mapState(&#123;  //用mapState来获取collection.js里面的state的属性值</span><br><span class="line">       //    arrList:state=&gt;state.collection.collects</span><br><span class="line">       // &#125;),</span><br><span class="line">       ...mapGetters(<span class="string">'collection'</span>,&#123; //用mapGetters来获取collection.js里面的getters</span><br><span class="line">           arrList:<span class="string">'renderCollects'</span></span><br><span class="line">       &#125;)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>至此，vuex 中的常用的一些知识点使用算是简单的分享完了，当然了，相信这些只是一些皮毛！只能说是给予刚接触 vuex 的初学者一个参考与了解吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 SPA 单页面组件的开发中 Vue 的 vuex 和 React 的 Redux 都统称为同一状态管理，个人的理解是全局状态管理更合适；简单的理解就是你在 state 中定义了一个数据之后，你可以在所在项目中的任何一个组件里进行获取、进行修改，并且你的修改可以得到全局的响应变更。下面咱们一步一步地剖析下 vuex 的使用:&lt;br&gt;首先要安装、使用 vuex&lt;br&gt;首先在 vue 2.0+ 你的 vue-cli 项目中安装 vuex :&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install vuex --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>【转】如何解决内存泄漏引发的血案</title>
    <link href="http://yoursite.com/2018/10/10/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/"/>
    <id>http://yoursite.com/2018/10/10/如何解决内存泄漏引发的血案/</id>
    <published>2018-10-10T05:52:48.000Z</published>
    <updated>2021-12-21T06:01:32.587Z</updated>
    
    <content type="html"><![CDATA[<p>之前做了一个谷歌浏览器的插件开发，它会打开一个链接，然后收集数据并上传。依次循环，但是跑的时间久了，内存就变得很高，然后浏览器就会变卡，慢慢的影响这个插件的运行，最后浏览器也会崩溃。</p><h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。在 C++ 中，因为是手动管理内存，内存泄露是经常出现的事情。而现在流行的 C# 和 Java 等语言采用了自动垃圾回收方法管理内存，正常使用的情况下几乎不会发生内存泄露。浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有 bug，会产生内存泄露。</p><a id="more"></a><p>自动垃圾收集是不能代替有效的内存管理的，特别是在大型，长时间运行的 Web 应用程序中。</p><h2 id="内存泄漏的几种情况"><a href="#内存泄漏的几种情况" class="headerlink" title="内存泄漏的几种情况"></a>内存泄漏的几种情况</h2><p>1、Delete 一个 Object 的属性会让此对象变慢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="string">"y"</span> &#125;;</span><br><span class="line"><span class="keyword">delete</span> obj; <span class="comment">// 此时 obj 会成一个慢对象</span></span><br><span class="line">obj.x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="string">"y"</span> &#125;;</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 应该这样</span></span><br></pre></td></tr></table></figure><p>2、闭包<br>1）在闭包中引入闭包外部的变量时，当闭包结束时此对象无法被垃圾回收（GC）。<br>2）闭包可以维持函数内局部变量，使其得不到释放。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> largeStr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">"x"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> largeStr;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>3、DOM 泄漏<br>当原有的 DOM 被移除时，子节点引用没有被移除则无法回收<br>当页面中元素被移除或替换时，若元素绑定的事件仍没被移除，在 IE 中不会作出恰当处理，此时要先手工移除事件，不然会存在内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBth"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = <span class="string">"test memory"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>应改成下面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBth"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  btn.onclick = <span class="literal">null</span>;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML = <span class="string">"test memory"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4、Timers 计(定)时器泄漏<br>定时器也是常见产生内存泄露的地方</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">90000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    callAgain: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> ref = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">var</span> val = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        ref.callAgain();</span><br><span class="line">      &#125;, <span class="number">90000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  obj.callAgain();</span><br><span class="line">  <span class="comment">// 虽然你想回收但是 timer 还在</span></span><br><span class="line">  obj = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、jquery 的 html() 函数<br>页面中还需要注意的一点是使用 jquery 的 html() 函数，该函数不是基于 innerHTML 实现的，大量使用同样也会导致系统性能下降。</p><p>6、使用事件委托代替事件注册<br>页面中如果元素过多，且需要为每个元素注册相同的 click 事件，这个时候我们优先考虑到使用委托机制，将需要注册的 click 事件注册到元素的上层或者顶层元素，这样我们就节省了大量的 click 注册事件。</p><p>7、自动类型装箱转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"test test"</span>;</span><br><span class="line">alert(s.length);</span><br></pre></td></tr></table></figure><p>s 本身是一个 string 而非 object，它没有 length 属性，所以当访问 length 时，JS 引擎会自动创建一个临时 String 对象封装 s，而这个对象一定会泄漏。这个 bug 匪夷所思，所幸解决起来相当容易，记得所有值类型做.运算之前先显示转换一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"test test"</span>;</span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">String</span>(s).length);</span><br></pre></td></tr></table></figure><h2 id="调试内存"><a href="#调试内存" class="headerlink" title="调试内存"></a>调试内存</h2><p>1、Timeline<br>Chrome 自带的内存调试工具可以很方便的查看内存使用情况和内存泄漏：<br>F12 -&gt; Timeline -&gt; Memory<br>点击 record 即可开始收集，点击弹出框的 Finish 即停止，然后会统计出 record 到 Finish 这一段时间内的内存使用情况。</p><p>2、Profiles<br>Chrome 自带的 Profiles 可以记录当前的内存使用情况<br>F12 -&gt; Profiles -&gt; Take Heap Snapshot<br>点击 Take Snapshot 就可以拍下当前 JS 的 heap 快照。<br><em>注意：每次拍快照前，都会先自动执行一个 GC，所以在视图里的对象都是可及的。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前做了一个谷歌浏览器的插件开发，它会打开一个链接，然后收集数据并上传。依次循环，但是跑的时间久了，内存就变得很高，然后浏览器就会变卡，慢慢的影响这个插件的运行，最后浏览器也会崩溃。&lt;/p&gt;
&lt;h2 id=&quot;什么是内存泄漏&quot;&gt;&lt;a href=&quot;#什么是内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;什么是内存泄漏&quot;&gt;&lt;/a&gt;什么是内存泄漏&lt;/h2&gt;&lt;p&gt;内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。在 C++ 中，因为是手动管理内存，内存泄露是经常出现的事情。而现在流行的 C# 和 Java 等语言采用了自动垃圾回收方法管理内存，正常使用的情况下几乎不会发生内存泄露。浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有 bug，会产生内存泄露。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>关于XSS攻击</title>
    <link href="http://yoursite.com/2018/09/29/%E5%85%B3%E4%BA%8EXSS%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/09/29/关于XSS攻击/</id>
    <published>2018-09-29T09:28:09.000Z</published>
    <updated>2021-12-21T06:02:50.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常见的-xss-攻击方法"><a href="#常见的-xss-攻击方法" class="headerlink" title="常见的 xss 攻击方法"></a>常见的 xss 攻击方法</h1><h2 id="1-绕过-XSS-Filter"><a href="#1-绕过-XSS-Filter" class="headerlink" title="1.绕过 XSS-Filter"></a>1.绕过 XSS-Filter</h2><p>利用&lt;&gt;标签注入 Html/JavaScript 代码。</p><h2 id="2-利用-HTML-标签的属性值进行-xss-攻击"><a href="#2-利用-HTML-标签的属性值进行-xss-攻击" class="headerlink" title="2.利用 HTML 标签的属性值进行 xss 攻击"></a>2.利用 HTML 标签的属性值进行 xss 攻击</h2><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：&lt;img src=<span class="string">"javascript:alert('xss')"</span>/&gt;;</span><br></pre></td></tr></table></figure><p>（当然并不是所有的 Web 浏览器都支持 Javascript 伪协议，所以此类 XSS 攻击具有一定的局限性）。</p><h2 id="3-空格、回车和-Tab"><a href="#3-空格、回车和-Tab" class="headerlink" title="3. 空格、回车和 Tab"></a>3. 空格、回车和 Tab</h2><p>如果 XSS Filter 仅仅将敏感的输入字符列入黑名单，比如 javascript，用户可以利用空格、回车和 Tab 键来绕过过滤，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：&lt;img src=<span class="string">"javas  cript:alert(/xss/);"</span>/&gt;;</span><br></pre></td></tr></table></figure><h2 id="4-利用事件来执行跨站脚本"><a href="#4-利用事件来执行跨站脚本" class="headerlink" title="4. 利用事件来执行跨站脚本"></a>4. 利用事件来执行跨站脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：&lt;img src=<span class="string">"#"</span> onerror=<span class="string">"alert(1)"</span>/&gt;;</span><br></pre></td></tr></table></figure><p>当 src 错误的视乎就会执行 onerror 事件。</p><h2 id="5-利用-CSS-跨站"><a href="#5-利用-CSS-跨站" class="headerlink" title="5. 利用 CSS 跨站"></a>5. 利用 CSS 跨站</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：Body &#123;backgrund-image: url(<span class="string">"javascript:alert('xss')"</span>)&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-扰乱过滤规则"><a href="#6-扰乱过滤规则" class="headerlink" title="6. 扰乱过滤规则"></a>6. 扰乱过滤规则</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：&lt;img src=<span class="string">"javaSCript: alert(/xss/);"</span>/&gt;;</span><br></pre></td></tr></table></figure><h2 id="7-利用字符编码"><a href="#7-利用字符编码" class="headerlink" title="7.利用字符编码"></a>7.利用字符编码</h2><p>透过这种技巧，不仅能让 XSS 代码绕过服务端的过滤，还能更好地隐藏 Shellcode；（JS 支持 unicode、eacapes、十六进制、十进制等编码形式）。</p><h2 id="8-拆分跨站法"><a href="#8-拆分跨站法" class="headerlink" title="8.拆分跨站法"></a>8.拆分跨站法</h2><p>将 xss 攻击的代码拆分开来，适用于应用程序没有过滤 XSS 关键字符（如<code>&lt;、&gt;</code>）却对输入字符长度有限制的情况下。</p><h2 id="9-DOM-型的-XSS"><a href="#9-DOM-型的-XSS" class="headerlink" title="9.DOM 型的 XSS"></a>9.DOM 型的 XSS</h2><p>DOM 型的 XSS 主要是由客户端的脚本通过 DOM 动态地输出数据到页面上，它不依赖于提交数据到服务器，而是从客户端获得 DOM 中的数据在本地执行。容易导致 DOM 型的 XSS 的输入源包括：<code>Document.URL</code>、<code>Location(.pathname|.href|.search|.hash)</code>、<code>Document.referrer</code>、<code>Window.name</code>、<code>Document.cookie</code>、<code>localStorage/globalStorage</code>；</p><h1 id="XSS-攻击防御"><a href="#XSS-攻击防御" class="headerlink" title="XSS 攻击防御"></a>XSS 攻击防御</h1><p>原则：不相信客户输入的数据<br>　　注意: 攻击代码不一定在<code>&lt;script&gt;&lt;/script&gt;</code>中</p><h2 id="1-使用-XSS-Filter。"><a href="#1-使用-XSS-Filter。" class="headerlink" title="1.使用 XSS Filter。"></a>1.使用 XSS Filter。</h2><p>输入过滤，对用户提交的数据进行有效性验证，仅接受指定长度范围内并符合我们期望格式的的内容提交，阻止或者忽略除此外的其他任何数据。比如：电话号码必须是数字和中划线组成，而且要设定长度上限。过滤一些些常见的敏感字符，例如：<code>&lt; &gt; &#39; &quot; &amp; # \ javascript expression &quot;onclick=&quot; &quot;onfocus&quot;</code>；过滤或移除特殊的 Html 标签，<br>例如: <code>&lt;script&gt;</code>, <code>&lt;iframe&gt;</code> , &lt; for &lt;, &gt; for &gt;, &quot; for；过滤 JavaScript 事件的标签，例如 “onclick=”, “onfocus” 等等。<br>输出编码，当需要将一个字符串输出到 Web 网页时，同时又不确定这个字符串中是否包括 XSS 特殊字符（如<code>&lt; &gt; &amp; &#39;&quot;</code>等），为了确保输出内容的完整性和正确性，可以使用编码（HTMLEncode）进行处理。</p><h2 id="2-DOM-型的-XSS-攻击防御"><a href="#2-DOM-型的-XSS-攻击防御" class="headerlink" title="2.DOM 型的 XSS 攻击防御"></a>2.DOM 型的 XSS 攻击防御</h2><p>把变量输出到页面时要做好相关的编码转义工作，如要输出到 <code>&lt;script&gt;</code>中，可以进行 JS 编码；要输出到 HTML 内容或属性，则进行 HTML 编码处理。根据不同的语境采用不同的编码处理方式。</p><h2 id="3-HttpOnly-Cookie"><a href="#3-HttpOnly-Cookie" class="headerlink" title="3.HttpOnly Cookie"></a>3.HttpOnly Cookie</h2><p>将重要的 cookie 标记为 http only，这样的话当浏览器向 Web 服务器发起请求的时就会带上 cookie 字段，但是在脚本中却不能访问这个 cookie，这样就避免了 XSS 攻击利用 JavaScript 的<code>document.cookie</code>获取 cookie。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;常见的-xss-攻击方法&quot;&gt;&lt;a href=&quot;#常见的-xss-攻击方法&quot; class=&quot;headerlink&quot; title=&quot;常见的 xss 攻击方法&quot;&gt;&lt;/a&gt;常见的 xss 攻击方法&lt;/h1&gt;&lt;h2 id=&quot;1-绕过-XSS-Filter&quot;&gt;&lt;a href=&quot;#1-绕过-XSS-Filter&quot; class=&quot;headerlink&quot; title=&quot;1.绕过 XSS-Filter&quot;&gt;&lt;/a&gt;1.绕过 XSS-Filter&lt;/h2&gt;&lt;p&gt;利用&amp;lt;&amp;gt;标签注入 Html/JavaScript 代码。&lt;/p&gt;
&lt;h2 id=&quot;2-利用-HTML-标签的属性值进行-xss-攻击&quot;&gt;&lt;a href=&quot;#2-利用-HTML-标签的属性值进行-xss-攻击&quot; class=&quot;headerlink&quot; title=&quot;2.利用 HTML 标签的属性值进行 xss 攻击&quot;&gt;&lt;/a&gt;2.利用 HTML 标签的属性值进行 xss 攻击&lt;/h2&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>centos7中安装mysql的步骤</title>
    <link href="http://yoursite.com/2018/09/25/centos7%E4%B8%AD%E5%AE%89%E8%A3%85mysql%E7%9A%84%E6%AD%A5%E9%AA%A4/"/>
    <id>http://yoursite.com/2018/09/25/centos7中安装mysql的步骤/</id>
    <published>2018-09-25T06:21:18.000Z</published>
    <updated>2018-09-25T09:06:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载源码包，一般将源码包放在-usr-local-中"><a href="#下载源码包，一般将源码包放在-usr-local-中" class="headerlink" title="下载源码包，一般将源码包放在/usr/local/中"></a>下载源码包，一般将源码包放在/usr/local/中</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">mkdir -p tools</span><br><span class="line"><span class="built_in">cd</span> tools</span><br><span class="line">wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">(这里的版本可以随时去mysql官网进行选择)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="查看系统中是否已安装-MySQL-服务"><a href="#查看系统中是否已安装-MySQL-服务" class="headerlink" title="查看系统中是否已安装 MySQL 服务"></a>查看系统中是否已安装 MySQL 服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep mysql</span><br><span class="line">或</span><br><span class="line">yum list installed | grep mysql</span><br></pre></td></tr></table></figure><h2 id="如果已安装则删除-MySQL-及其依赖的包"><a href="#如果已安装则删除-MySQL-及其依赖的包" class="headerlink" title="如果已安装则删除 MySQL 及其依赖的包"></a>如果已安装则删除 MySQL 及其依赖的包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y remove mysql-libs.x86_64</span><br></pre></td></tr></table></figure><h2 id="安装-mysql57-community-release-el7-8-noarch-rpm"><a href="#安装-mysql57-community-release-el7-8-noarch-rpm" class="headerlink" title="安装 mysql57-community-release-el7-8.noarch.rpm"></a>安装 mysql57-community-release-el7-8.noarch.rpm</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">安装完后，得到如下两个包：（在/etc/yum.repos.d/文件下）</span><br><span class="line">mysql-community.repo</span><br><span class="line">mysql-community-source.repo</span><br></pre></td></tr></table></figure><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mysql-server</span><br></pre></td></tr></table></figure><p>根据步骤安装就可以了，不过安装完成后，没有密码，需要重置密码。</p><h2 id="重置密码："><a href="#重置密码：" class="headerlink" title="重置密码："></a>重置密码：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root；</span><br><span class="line">报错：ERROR 2002 (HY000): Can‘t connect to <span class="built_in">local</span> MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)，原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户：</span><br><span class="line">sudo chown -R openscanner:openscanner /var/lib/mysql</span><br><span class="line">重启服务：</span><br><span class="line"> service mysqld restart</span><br><span class="line">再次登录:</span><br><span class="line">mysql -u root</span><br></pre></td></tr></table></figure><p>报错：</p><p>此种情况是因为存在了默认密码问题，解决：（最保险的是重置root密码）</p><h3 id="修改-etc-my-cnf"><a href="#修改-etc-my-cnf" class="headerlink" title="修改 /etc/my.cnf"></a>修改 /etc/my.cnf</h3><p>在 [mysqld] 小节下添加一行：skip-grant-tables=1<br>这一行配置让 mysqld 启动时不对密码进行验证</p><h3 id="重启-mysqld-服务"><a href="#重启-mysqld-服务" class="headerlink" title="重启 mysqld 服务"></a>重启 mysqld 服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure><h3 id="使用-root-用户登录到-mysql"><a href="#使用-root-用户登录到-mysql" class="headerlink" title="使用 root 用户登录到 mysql"></a>使用 root 用户登录到 mysql</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure><h3 id="切换到mysql数据库，更新user表"><a href="#切换到mysql数据库，更新user表" class="headerlink" title="切换到mysql数据库，更新user表"></a>切换到mysql数据库，更新user表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user <span class="built_in">set</span> authentication_string = password(<span class="string">'root'</span>), password_expired = <span class="string">'N'</span>, password_last_changed = now() <span class="built_in">where</span> user = <span class="string">'root'</span>;</span><br></pre></td></tr></table></figure><p>在之前的版本中，密码字段的字段名是 password，5.7版本改为了 authentication_string</p><h3 id="退出-mysql，编辑-etc-my-cnf-文件，删除-skip-grant-tables-1-的内容"><a href="#退出-mysql，编辑-etc-my-cnf-文件，删除-skip-grant-tables-1-的内容" class="headerlink" title="退出 mysql，编辑 /etc/my.cnf 文件，删除 skip-grant-tables=1 的内容"></a>退出 mysql，编辑 /etc/my.cnf 文件，删除 skip-grant-tables=1 的内容</h3><h3 id="重启-mysqld-服务，再用新密码登录即可"><a href="#重启-mysqld-服务，再用新密码登录即可" class="headerlink" title="重启 mysqld 服务，再用新密码登录即可"></a>重启 mysqld 服务，再用新密码登录即可</h3><h3 id="修改root用户对于访问主机的权限修改，user表中的root账户默认只允许本机localhost进行链接；需要进行如下修改："><a href="#修改root用户对于访问主机的权限修改，user表中的root账户默认只允许本机localhost进行链接；需要进行如下修改：" class="headerlink" title="修改root用户对于访问主机的权限修改，user表中的root账户默认只允许本机localhost进行链接；需要进行如下修改："></a>修改root用户对于访问主机的权限修改，user表中的root账户默认只允许本机localhost进行链接；需要进行如下修改：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p;</span><br><span class="line">输入密码；</span><br><span class="line">use mysql;</span><br><span class="line">update user <span class="built_in">set</span> host=’%’<span class="built_in">where</span> user=’root’;</span><br></pre></td></tr></table></figure><h3 id="开放防火墙"><a href="#开放防火墙" class="headerlink" title="开放防火墙"></a>开放防火墙</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/iptables</span><br><span class="line">添加以下内容：</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT</span><br><span class="line">保存后重启防火墙：</span><br><span class="line">$ sudo service iptables restart</span><br><span class="line">这样从其它客户机也可以连接上mysql服务了。</span><br></pre></td></tr></table></figure><h3 id="阿里云安全组设置"><a href="#阿里云安全组设置" class="headerlink" title="阿里云安全组设置"></a>阿里云安全组设置</h3><p>如果此时在其他客户机上还是链接不上mysql，登录阿里云，查看实例的安全组有没有为3306端口开启规则；</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;下载源码包，一般将源码包放在-usr-local-中&quot;&gt;&lt;a href=&quot;#下载源码包，一般将源码包放在-usr-local-中&quot; class=&quot;headerlink&quot; title=&quot;下载源码包，一般将源码包放在/usr/local/中&quot;&gt;&lt;/a&gt;下载源码包，一般将源码包放在/usr/local/中&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; /usr/&lt;span class=&quot;built_in&quot;&gt;local&lt;/span&gt;/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir -p tools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; tools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(这里的版本可以随时去mysql官网进行选择)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>centos7中搭建nginx</title>
    <link href="http://yoursite.com/2018/09/25/centos7%E4%B8%AD%E6%90%AD%E5%BB%BAnginx/"/>
    <id>http://yoursite.com/2018/09/25/centos7中搭建nginx/</id>
    <published>2018-09-25T06:10:16.000Z</published>
    <updated>2018-09-25T09:07:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>nginx可以使用各平台的默认包来安装，本文是介绍使用源码编译安装，包括具体的编译参数信息。<br>正式开始前，编译环境gcc g++ 开发库之类的需要提前装好，这里默认你已经装好。<br><a id="more"></a><br>centos平台编译环境使用如下指令<br>安装make：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc automake autoconf libtool make</span><br></pre></td></tr></table></figure></p><p>安装g++:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc gcc-c++</span><br></pre></td></tr></table></figure></p><p>下面正式开始：<br>一般我们都需要先装pcre, zlib，前者为了重写rewrite，后者为了gzip压缩。</p><p>注：下面所使用的所有版本均为截止2017年8月14号，最新版本</p><h2 id="选定源码目录"><a href="#选定源码目录" class="headerlink" title="选定源码目录"></a>选定源码目录</h2><p>可以是任何目录，本文选定的是/usr/local/src<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br></pre></td></tr></table></figure></p><h2 id="安装PCRE库"><a href="#安装PCRE库" class="headerlink" title="安装PCRE库"></a>安装PCRE库</h2><p><a href="ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/" target="_blank" rel="noopener">ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/</a> 下载最新的 PCRE 源码包，使用下面命令下载编译和安装 PCRE 包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.41.tar.gz </span><br><span class="line">tar -zxvf pcre-8.41.tar.gz</span><br><span class="line"><span class="built_in">cd</span> pcre-8.41</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><h2 id="安装zlib库"><a href="#安装zlib库" class="headerlink" title="安装zlib库"></a>安装zlib库</h2><p><a href="http://zlib.net/zlib-1.2.11.tar.gz" target="_blank" rel="noopener">http://zlib.net/zlib-1.2.11.tar.gz</a> 下载最新的 zlib 源码包，使用下面命令下载编译和安装 zlib包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget http://zlib.net/zlib-1.2.11.tar.gz</span><br><span class="line">tar -zxvf zlib-1.2.11.tar.gz</span><br><span class="line"><span class="built_in">cd</span> zlib-1.2.11</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><h2 id="安装ssl（某些vps默认没装ssl"><a href="#安装ssl（某些vps默认没装ssl" class="headerlink" title="安装ssl（某些vps默认没装ssl)"></a>安装ssl（某些vps默认没装ssl)</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget https://www.openssl.org/<span class="built_in">source</span>/openssl-1.0.2l.tar.gz</span><br><span class="line">tar -zxvf openssl-1.0.2l.tar.gz</span><br></pre></td></tr></table></figure><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>Nginx 一般有两个版本，分别是稳定版和开发版，您可以根据您的目的来选择这两个版本的其中一个，下面是把 Nginx 安装到 /usr/local/nginx 目录下的详细步骤：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget http://nginx.org/download/nginx-1.13.4.tar.gz</span><br><span class="line">tar -zxvf nginx-1.13.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx-1.13.4</span><br><span class="line"></span><br><span class="line">./configure --sbin-path=/usr/<span class="built_in">local</span>/nginx/nginx \</span><br><span class="line">--conf-path=/usr/<span class="built_in">local</span>/nginx/nginx.conf \</span><br><span class="line">--pid-path=/usr/<span class="built_in">local</span>/nginx/nginx.pid \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-pcre=/usr/<span class="built_in">local</span>/src/pcre-8.41 \</span><br><span class="line">--with-zlib=/usr/<span class="built_in">local</span>/src/zlib-1.2.11 \</span><br><span class="line">--with-openssl=/usr/<span class="built_in">local</span>/src/openssl-1.0.2l</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"> --with-pcre=/usr/<span class="built_in">local</span>/src/pcre-8.41 指的是pcre-8.41 的源码路径。</span><br><span class="line">--with-zlib=/usr/<span class="built_in">local</span>/src/zlib-1.2.11 指的是zlib-1.2.11 的源码路径。</span><br></pre></td></tr></table></figure></p><p>安装成功：<br>安装成功后 /usr/local/nginx 会有此目录</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>确保系统的 80 端口没被其他程序占用，运行/usr/local/nginx/nginx 命令来启动 Nginx， </p><p>打开浏览器访问此机器的 IP，如果浏览器出现 Welcome to nginx! 则表示 Nginx 已经安装并运行成功。</p><hr><p>到这里nginx就安装完成了，如果只是处理静态html就不用继续安装了<br>如果你需要处理php脚本的话，还需要安装php-fpm。</p><h2 id="常见错误："><a href="#常见错误：" class="headerlink" title="常见错误："></a>常见错误：</h2><p>附：可能遇到的错误和一些帮助信息</p><h3 id="编译pcre错误"><a href="#编译pcre错误" class="headerlink" title="编译pcre错误"></a>编译pcre错误</h3><p>make[1]: Leaving directory `/usr/local/src/pcre-8.34’<br>make: *** [all] Error 2</p><p>解决办法：安装g++,别忘了重新configure<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install g++</span><br><span class="line">apt-get install build-essential</span><br><span class="line">make clean</span><br><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure></p><h3 id="make出错"><a href="#make出错" class="headerlink" title="make出错"></a>make出错</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make: *** No targets specified and no makefile found.  Stop.</span><br></pre></td></tr></table></figure><p>按照下面安装方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install openssl openssl-devel</span><br></pre></td></tr></table></figure></p><h3 id="nginx编译选项（下面代码必须在一行）"><a href="#nginx编译选项（下面代码必须在一行）" class="headerlink" title="nginx编译选项（下面代码必须在一行）"></a>nginx编译选项（下面代码必须在一行）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./configure --sbin-path=/usr/<span class="built_in">local</span>/nginx/nginx \</span><br><span class="line">--conf-path=/usr/<span class="built_in">local</span>/nginx/nginx.conf \</span><br><span class="line">--pid-path=/usr/<span class="built_in">local</span>/nginx/nginx.pid \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-pcre=/usr/<span class="built_in">local</span>/src/pcre-8.41 \</span><br><span class="line">--with-zlib=/usr/<span class="built_in">local</span>/src/zlib-1.2.11 \</span><br><span class="line">--with-openssl=/usr/<span class="built_in">local</span>/src/openssl-1.0.2l</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;nginx可以使用各平台的默认包来安装，本文是介绍使用源码编译安装，包括具体的编译参数信息。&lt;br&gt;正式开始前，编译环境gcc g++ 开发库之类的需要提前装好，这里默认你已经装好。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="centos" scheme="http://yoursite.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>徙鸟</title>
    <link href="http://yoursite.com/2018/09/25/%E5%BE%99%E9%B8%9F/"/>
    <id>http://yoursite.com/2018/09/25/徙鸟/</id>
    <published>2018-09-25T05:55:10.000Z</published>
    <updated>2018-09-25T05:59:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>人拥有那么几次，只想放下包袱，走走停停，不求结伴只求独行，想去看沼泽地里盛开的芦苇花，藏身其中躺在小木船上，有一顶草帽遮住阳光，直到太阳穿过草帽的缝隙，刺痛双眼，喊一嗓子，可以惊起一滩鸥鹭，芦苇花飞，风扶过千层浪，远处只有夕阳，到深夜明月千里寄相思，船上飘荡着鱼香，远处乎明乎暗的丝丝篝火，缕缕青烟！</p><a id="more"></a><p>去看江南水乡的白墙青瓦，烟雨断桥白牡丹，杨柳枝头喜鹊吟。一首红楼惹人愁的梦魇，不求相遇断桥只愿擦肩人海，石板青苔筑小巷，踏过青苔满布的江南小巷，一头头石狮向我仰望，真羡慕雨巷走过遇撑油纸伞的姑娘，我一路走来，雨水撞击青石板叮当作响，清脆刺骨，一路走来却少了丁香的芬芳，</p><p>最想去的还是冬日冰封千里，万里雪飘的北方，寒风凛冽嘶吼，犹如饥饿的狼群又好似无家可归的孩子在深夜抽泣，真像游走在人世与地狱之间的孤魂，苍茫大地一串串踏踏实实的走过，变成模板的刻印。这就是我无数次魂牵梦绕。又无数次辗转反侧的故乡，斑驳的土地，干裂撕扯出一道道缝隙，在那里隐藏着多少荒凉与悲，孤身立于荒野，透过刺骨的疾风能听到枯草摩擦发出的嘶吼，使人无法不去敬畏这里的每一个生灵，</p><p>西北风不停的叫着，一夜一夜，天变得越来越冷，曾经高大威猛的杨树如今就像年迈七殉的老人，佝偻驼背，露骨脊梁。风还在吹，夜夜无休拍打窗户。蜷缩的身体夜夜无眠。终于迎来一场苍天的恩赐，俗世尘埃无落，污秽难停。这里是纯洁圣地，</p><p>清晨，万里银光，一尘不染。岁月年华在这没有留下足迹，我看到的只是这片土地上子民脸上风刻的印记，热血般鲜红炽热的双手触摸大地的灵魂，双手间雪瞬间融化，水滴在这片土地，早已张开的打算畅饮的裂缝像大西北的汉子饮酒般痛饮，咕咚咕咚的声音不知陶醉了多少姑娘的芳心。</p><p>我的脚步走走停停，我的心却从未远离。</p><p>这片土地沉淀了多少历史的沧桑，多少辛酸疾苦，这里祖祖辈辈永不抛弃，这里个个少年挺起脊梁。</p><p><img src="http://image.codes51.com/Article/image/20160521/20160521034958_0116.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人拥有那么几次，只想放下包袱，走走停停，不求结伴只求独行，想去看沼泽地里盛开的芦苇花，藏身其中躺在小木船上，有一顶草帽遮住阳光，直到太阳穿过草帽的缝隙，刺痛双眼，喊一嗓子，可以惊起一滩鸥鹭，芦苇花飞，风扶过千层浪，远处只有夕阳，到深夜明月千里寄相思，船上飘荡着鱼香，远处乎明乎暗的丝丝篝火，缕缕青烟！&lt;/p&gt;
    
    </summary>
    
      <category term="美文" scheme="http://yoursite.com/categories/%E7%BE%8E%E6%96%87/"/>
    
    
      <category term="essay" scheme="http://yoursite.com/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>webpack基础</title>
    <link href="http://yoursite.com/2018/09/21/webpack%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/09/21/webpack基础/</id>
    <published>2018-09-21T01:27:32.000Z</published>
    <updated>2021-12-21T06:04:10.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><p>Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。<br>webpack 已经是大部分前端项目打包工具的首选，grunt、glup、browserify、fis 等逐渐沦为辅助甚至完全被替代。</p><a id="more"></a><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><p>注册 cnpm：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>全局安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack</span><br></pre></td></tr></table></figure><p>项目安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm init</span><br><span class="line">cnpm install –save-dev webpack</span><br></pre></td></tr></table></figure><h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><ol><li>无配置文件使用：<br>webpack 源文件 目标文件<br>例：webpack index.js bound.js</li><li>使用配置文件：<br>默认配置文件:<br>webpack.config.js<br>可以配置多个 config 文件</li></ol><h2 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h2><p>关于 webpack.config.js 的配置规则如下：<br>需要采用 common.js 规范进行文件的抛出一个 webpack 的配置对象：<br>module.exports={}</p><h3 id="入口文件属性："><a href="#入口文件属性：" class="headerlink" title="入口文件属性："></a>入口文件属性：</h3><h4 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry：__dirname+文件路径  //__dirname是node的全局文件根目录，推荐采用此种写法；</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry：./文件路径  //此种写法,貌似在3.0版本中不再支持，不推荐此种写法</span><br></pre></td></tr></table></figure><h4 id="对象语法："><a href="#对象语法：" class="headerlink" title="对象语法："></a>对象语法：</h4><p>a) 单入口文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">entry：&#123;</span><br><span class="line">main：__dirname+文件路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b) 多入口文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry：&#123;</span><br><span class="line">app1：__dirname+文件路径，</span><br><span class="line">app2：__dirname+文件路径，</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出文件属性："><a href="#输出文件属性：" class="headerlink" title="输出文件属性："></a>输出文件属性：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output：&#123;</span><br><span class="line">    path: __dirname+文件路径  //__dirname是node的全局文件根目录，采用此种写法；</span><br><span class="line">    path：./文件路径  //此种写法不支持</span><br><span class="line">    filename：输出文件名  //如果多入口文件，不能指定文件名，需要使用[name]动态获取；</span><br><span class="line">    chunkFilename:[name][<span class="built_in">hash</span>] //name为模块的名字，<span class="built_in">hash</span>加入<span class="built_in">hash</span>值，防止缓存，使用此属性是，模块的引入必须结合require.ensure方法，否则此方法无效；</span><br><span class="line">    publicPath:设置服务路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载器："><a href="#加载器：" class="headerlink" title="加载器："></a>加载器：</h3><p>1、 语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;<span class="built_in">test</span>: /\.css$/, use: [<span class="string">'css-loader'</span>](/loaders/css-loader)&#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>2、 rules 数组中每个规则的属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>：要匹配的文件类型；</span><br><span class="line">use:使用何种加载器进行加载处理文件，可以同时使用多个loader，数组的形式；数组的值，可以为字符串，或者对象；</span><br><span class="line">loader：使用何种加载器加载处理文件，只能加载一个loader。字符串形式；</span><br><span class="line">options：加载器的配置项;</span><br></pre></td></tr></table></figure><p>3、 常用的 loader：<br>style-loader、css-loader、url-loader、html-loader、babel-loader、eslint-loader、vue-loader……</p><h3 id="插件："><a href="#插件：" class="headerlink" title="插件："></a>插件：</h3><p>1、 语法：<br>plugins：[ ]<br>2、 常用插件：<br>a) 内置插件<br>UglifyJsPlugin、HotModuleReplacementPlugin、CommonsChunkPlugin……<br>配置项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name：( 公共chunk(commnons chunk) 的名称),</span><br><span class="line">    filename：( 公共chunk 的文件名)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b) 三方插件<br>HtmlWebpackPlugin<br>配置项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    template：<span class="string">""</span> //入口html的路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="devtool"><a href="#devtool" class="headerlink" title="devtool:"></a>devtool:</h3><p>1、 开发环境：推荐使用（cheap-module-eval-source-map）<br>eval-source-map: 每个模块使用 eval() 执行，并且 SourceMap 转换为 DataUrl 后添加到 eval() 中。初始化 SourceMap 时比较慢，但是会在重构建时提供很快的速度，并且生成实际的文件。行数能够正确映射，因为会映射到原始代码中。<br>cheap-module-eval-source-map：”低开销”是因为它没有生成列映射(column map)，只是映射行数；<br>2、 生产环境：推荐使用（source-map）<br>source-map - 生成完整的 SourceMap，输出为独立文件。由于在 bundle 中添加了引用注释，所以开发工具知道在哪里去找到 SourceMap。</p><h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer:"></a>devServer:</h3><p>1、 基于 webpack 的静态服务：<br>2、 配置项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment"># 告诉服务器从哪里提供内容。这只有在您想要提供静态文件时才需要。例如图片？？</span></span><br><span class="line">contentBase：__dirname + <span class="string">'dist'</span>,</span><br><span class="line">    <span class="comment"># 告诉服务器观看由devServer.contentBase选项提供的文件。文件更改将触发整个页面重新加载。</span></span><br><span class="line">watchContentBase: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment"># 随所有内容启用gzip压缩</span></span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment"># 模块的热加载，必须结合 HotModuleReplacementPlugin使用</span></span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    port: 9999,</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    <span class="comment"># 相当于gulp的middleware中间件拦截请求；</span></span><br><span class="line">    setup(app) &#123;</span><br><span class="line">        app.get(<span class="string">'/some/path'</span>, <span class="keyword">function</span>(req, res) &#123;</span><br><span class="line">            console.log(11)</span><br><span class="line">            res.json(&#123; custom: <span class="string">'response'</span> &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">        <span class="comment"># "/api": "http://localhost:3000/"</span></span><br><span class="line">        <span class="comment"># "/": "http://localhost:3000/"</span></span><br><span class="line">        <span class="string">"/api"</span>: &#123;</span><br><span class="line">            target: <span class="string">"http://localhost:3000"</span>,</span><br><span class="line">            pathRewrite: &#123;<span class="string">"^/api"</span> : <span class="string">""</span>&#125;,</span><br><span class="line">            secure: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h2&gt;&lt;p&gt;Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。&lt;br&gt;webpack 已经是大部分前端项目打包工具的首选，grunt、glup、browserify、fis 等逐渐沦为辅助甚至完全被替代。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>一根油条的爱情</title>
    <link href="http://yoursite.com/2018/09/20/%E4%B8%80%E6%A0%B9%E6%B2%B9%E6%9D%A1%E7%9A%84%E7%88%B1%E6%83%85/"/>
    <id>http://yoursite.com/2018/09/20/一根油条的爱情/</id>
    <published>2018-09-20T09:42:18.000Z</published>
    <updated>2019-07-30T08:30:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3363703253,3105449005&amp;fm=173&amp;s=5EF82DC51E1308D000944C3D03008012&amp;w=500&amp;h=281&amp;img.JPEG" alt></p><p>那一年，她病了，他用板车拉着她去镇上找诊所看病。说了一箩筐的好话，掏出口袋里所有的硬币，郎中终于给她打了针，再塞给她两服黄竹纸包着的中药。</p><p>他拉着板车往回走，她依旧坐在板车上。穿过一条小街，向右拐，再穿过一条街，好香好香的气味儿飘过来，飘过来。他狠狠咽了口唾沫，迟疑几秒，止了步，回头：“你想吃油条不？”</p><p>板车上的她本来也在偷偷咽唾沫，忽儿听到他的问话，愣了愣，摇头：“不吃，不想吃。”她摁摁布包里那几个煮熟的红薯：“这有红薯呢，我要是饿了，会吃红薯的。”她清楚，他的兜里连一个碎角子都没了，哪来钱去买油条。<br><a id="more"></a></p><p>他静静地看着她，就像一下子，一下子看到她的心底里去了。她不好意思了，低头。该死的，那好香好香的气味儿又扑过来了，她情不自禁地又吞了吞唾沫。</p><p>将板车轻轻拉到街边，泊稳，他大踏步朝街角那个炸油条的小摊走去。她的目光追着他那肩宽背阔的身影，看着他站在摊主前戳戳点点。她脸红了，羞愧地闭上眼。天啊，我们不是乞丐呀，他怎么好意思向人家乞讨！再睁开眼，她便看到他笑吟吟举着一根油条朝她跑过来。</p><p>她生气，扭头：“我不吃。我不是乞丐，我不吃乞讨来的东西。”</p><p>他大声说：“谁说这油条是乞讨来的，我是拿烟丝换的。”</p><p>她诧异：“拿烟丝换的？那你想抽烟时咋办？”他抽烟好多年了，人家说“人是铁，饭是钢”，他却说“人是铁，烟是钢”。在他眼里，烟比饭重要。累了，他点支烟一吸，就来劲了；饿了，他点支烟一吸，就饱了。他抽的烟都是自家种植的旱烟，晒干后，烟叶切成丝装进小塑料袋再掖在兜里，想吸时，拿小纸片滚成“喇叭筒”。</p><p>他笑：“一天半天不抽烟，死不了的。再不济，烟瘾来了忍不了的话，就捡几片路边的干树叶搓碎了滚成喇叭筒，不也照样能抽能应应急……”他将油条递给她：“快吃，趁热，香香软软的。”</p><p>她说：“我们分着吃，你一半，我一半。”他摇头又摇头：“不，我不爱吃油腻的东西，你快吃。”</p><p>她咬了一口，眼睛就雾蒙蒙了，想擦擦，没擦。他还在高兴着，问：“香不香，甜不甜？”她脱口而出：“苦，好苦。”</p><p>他差点蹦起来：“苦？怎么会是苦的，我要师傅给炸一根最甜最香的哦。”她抬起头，皱眉头：“不信，你自己尝尝。”她用劲掐下大半截，狠狠塞进他的口里。他嚼了一下，再嚼一下，咦，奇了怪了，不苦，好甜好香，还暖和和的呀。</p><p>看他一脸摸不着头脑的疑惑样子，突然地，她扑哧一声笑出声来了。他，顷刻间，就明白怎么回事了。她只是“骗”他分享那一根油条呀，骗他吃下一根油条的大半截呀……</p><p>这个故事里的他，是我30年前的父亲。这个故事里的她，是我30年前的母亲。这个故事，父亲对我讲过“9999”次，母亲对我讲过“9999”次。父亲母亲讲述的“版本”有些出入。父亲总是忽略掉他用自己热爱的烟丝换油条的情节，却一再重申母亲骗他吃油条的细节。母亲总是强调父亲用烟丝换油条的细节，却扔了她骗父亲吃油条的情节。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=3363703253,3105449005&amp;amp;fm=173&amp;amp;s=5EF82DC51E1308D000944C3D03008012&amp;amp;w=500&amp;amp;h=281&amp;amp;img.JPEG&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;那一年，她病了，他用板车拉着她去镇上找诊所看病。说了一箩筐的好话，掏出口袋里所有的硬币，郎中终于给她打了针，再塞给她两服黄竹纸包着的中药。&lt;/p&gt;
&lt;p&gt;他拉着板车往回走，她依旧坐在板车上。穿过一条小街，向右拐，再穿过一条街，好香好香的气味儿飘过来，飘过来。他狠狠咽了口唾沫，迟疑几秒，止了步，回头：“你想吃油条不？”&lt;/p&gt;
&lt;p&gt;板车上的她本来也在偷偷咽唾沫，忽儿听到他的问话，愣了愣，摇头：“不吃，不想吃。”她摁摁布包里那几个煮熟的红薯：“这有红薯呢，我要是饿了，会吃红薯的。”她清楚，他的兜里连一个碎角子都没了，哪来钱去买油条。&lt;br&gt;
    
    </summary>
    
      <category term="美文" scheme="http://yoursite.com/categories/%E7%BE%8E%E6%96%87/"/>
    
    
      <category term="essay" scheme="http://yoursite.com/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/06/13/hello-world/"/>
    <id>http://yoursite.com/2018/06/13/hello-world/</id>
    <published>2018-06-13T02:19:02.000Z</published>
    <updated>2021-12-21T06:00:05.589Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. ChecK <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Posts"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. ChecK &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Posts&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="HEXO" scheme="http://yoursite.com/categories/HEXO/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
